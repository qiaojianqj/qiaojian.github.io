<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Caddy代替Nginx</title>
    <url>/article/Caddy%E4%BB%A3%E6%9B%BFNginx/</url>
    <content><![CDATA[<ol>
<li>安装</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl https://getcaddy.com | bash -s personal</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>caddy service启动脚本下载，注意修改user + group</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -s https://raw.githubusercontent.com/mholt/caddy/master/dist/init/linux-systemd/caddy.service -o /etc/systemd/system/caddy.service</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>配置Caddyfile读取配置目录（这些目录都是根据service启动脚本来配置的）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir /etc/caddy</span><br><span class="line">mkdir /etc/caddy/conf</span><br><span class="line">echo &apos;import ./conf/*&apos; &gt;&gt; /etc/caddy/Caddyfile #导入./conf目录下的所有文件作为caddy的配置文件</span><br><span class="line">mkdir /etc/ssl/caddy</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>配置文件放/etc/caddy/conf目录下，比如：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim /etc/caddy/conf/v2r.conf</span><br><span class="line">#配置反向代理</span><br><span class="line">:80 &#123;</span><br><span class="line">        proxy / 127.0.0.1:9090 &#123;</span><br><span class="line">                transparent</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当配置文件中指定域名时，caddy会自动从Let’s Encrypt申请免费https证书</p>
<ol start="5">
<li>启动caddy服务</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#centos7</span><br><span class="line">systemctl start caddy</span><br><span class="line">#查看启动是否成功</span><br><span class="line">systemctl status caddy</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>访问服务，验证代理是否生效（本地配置了hosts: 1.2.3.4 <a href="http://qj.com" target="_blank" rel="noopener">qj.com</a>）</li>
</ol>
<p><img src="https://qiaojiande-1259482780.cos.ap-chengdu.myqcloud.com/201908/caddy-check.jpg" alt=""></p>
<h2 id="vps克隆github博客">vps克隆github博客</h2>
<ol>
<li>
<p>git clone <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:qiaojianqj/qiaojianqj.github.io.git 到本地目录</p>
</li>
<li>
<p>配置caddy，https证书申请老是失败</p>
</li>
<li>
<p>改为nginx，配置一次性成功</p>
</li>
<li>
<p>看来个人博客用caddy会自动向let’s encrypt免费证书申请证书，但是失败机会大，nginx还是适合企业级使用</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>caddy</tag>
      </tags>
  </entry>
  <entry>
    <title>Controller_vs_RestController</title>
    <url>/article/Controller-vs-RestController/</url>
    <content><![CDATA[<p>Controller注解 返回值类型：</p>
<ol>
<li>ModelAndView<br>
页面和数据整合的类型，使用模版引擎时可使用这种方式</li>
<li>void<br>
此时，可以进行forward转发，request.getRequestDispatcher(“forwardUrl”).forward(request, response)（页面url不变）<br>
也可以进行redirect重定向，response.sendRedirect(“redirectUrl”) (页面url会跳转)<br>
还可以通过response.getWriter.write()直接返回页面数据</li>
<li>String<br>
Controller注解下，返回字符串默认是逻辑视图名称，功能同返回ModelAndView<br>
也可以进行redirect重定向，response.sendRedirect(“redirectUrl”) (页面url会跳转)，此时返回值无用<br>
还可以进行forward转发，request.getRequestDispatcher(“forwardUrl”).forward(request, response)（页面url不变），此时返回值无用</li>
<li>任意数据类型 + ResponseBody注解<br>
此时将返回值按照返回类型进行json解析，并返回json数据</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/hehe"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(path = <span class="string">"test"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(@RequestParam String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"HELLO "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(path = <span class="string">"testvoid"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testVoid</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                         HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                         @RequestParam String name)</span> </span>&#123;</span><br><span class="line">        response.setCharacterEncoding ( <span class="string">"utf-8"</span> );</span><br><span class="line">        response.setContentType ( <span class="string">"application/json; charset=utf-8"</span> );</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            response.getWriter ().write ( <span class="string">"response write data: "</span> + name );</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace ();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(path = <span class="string">"redirect1"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  String <span class="title">redirect1</span><span class="params">(@RequestParam String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"redirect:test?name="</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(path = <span class="string">"redirect2"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">redirect2</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                           HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                           @RequestParam String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            response.sendRedirect ( <span class="string">"/hehe/test?name="</span> + name );</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace ();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(path = <span class="string">"redirect3"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedirectView <span class="title">redirect3</span><span class="params">(@RequestParam String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RedirectView ( <span class="string">"/hehe/test?name="</span> + name );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(path = <span class="string">"forward1"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  String <span class="title">forward1</span><span class="params">(@RequestParam String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"forward:test"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(path = <span class="string">"forward2"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forward2</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">            @RequestParam String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             request.getRequestDispatcher ( <span class="string">"/hehe/test"</span> )</span><br><span class="line">                    .forward ( request, response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ServletException e) &#123;</span><br><span class="line">            e.printStackTrace ();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace ();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RestController注解 相当于 Controller注解 + ResponseBody注解，会对返回值进行JSON化处理并直接返回数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRestController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/rest"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HashMap (  );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello-World</title>
    <url>/article/Hello-World/</url>
    <content><![CDATA[<p>欢迎来到我的小站！</p>
]]></content>
  </entry>
  <entry>
    <title>Linux-进程替换</title>
    <url>/article/Linux-%E8%BF%9B%E7%A8%8B%E6%9B%BF%E6%8D%A2/</url>
    <content><![CDATA[<p>Linux 进程替换和管道类似，是输入输出重定向的一种， 它的语法如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">command &lt;(list)</span><br><span class="line">or</span><br><span class="line">command &gt;(list)</span><br></pre></td></tr></table></figure>
<p>注意这儿 () 与 &lt; 和 &gt; 之间没有空格。list可以是一个单独的命令或者是由管道连起来的一组命令。进程替换的作用是将&lt;(list)替换为一个文件描述符（/dev/fd/xx），文件的内容即是list的命令输出。</p>
<p>例如罗列当前目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &lt;(ls)		#把&lt;(ls)替换为一个临时文件，文件内容是ls的结果，最后cat这个临时文件</span><br><span class="line"> </span><br><span class="line">ls &gt; &gt;(cat)	#把&gt;(cat)替换为一个临时文件，ls的结果重定向到这个文件，最后这个文件被cat</span><br></pre></td></tr></table></figure>
<p>再例如比较两个文件的异同：</p>
<p><img src="https://qiaojiande-1259482780.cos.ap-chengdu.myqcloud.com/201908/linux-process-substitution.jpg" alt=""></p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot-集成WEB容器AccessLog配置</title>
    <url>/article/SpringBoot-%E9%9B%86%E6%88%90WEB%E5%AE%B9%E5%99%A8AccessLog%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>SpringBoot项目集成WEB容器tomcat、undertow，access log配置，注意两者的微小差别，tomcat的日志目录关键字是basedir，undertow是directory。tomcat的扩展打印http头日志格式是%{xxx}i，undertow的扩展打印http头日志格式是%{i,xxx}</p>
<ol>
<li>集成tomcat</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server.tomcat.basedir=$&#123;log.path&#125;</span><br><span class="line">server.tomcat.accesslog.enabled=true</span><br><span class="line">server.tomcat.accesslog.pattern=%t %a &quot;%r&quot; %s (%D ms)</span><br></pre></td></tr></table></figure>
<p>其中pattern 常用模式：common、combined</p>
<ul>
<li><strong>common</strong> - <code>%h %l %u %t &quot;%r&quot; %s %b</code></li>
<li><strong>combined</strong> - <code>%h %l %u %t &quot;%r&quot; %s %b &quot;%{Referer}i&quot; &quot;%{User-Agent}i&quot;</code></li>
</ul>
<p>自定义pattern：</p>
<p><img src="https://qiaojiande-1259482780.cos.ap-chengdu.myqcloud.com/201908/tomcat-access-log-pattern.jpg" alt=""></p>
<ol>
<li>集成undertow</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server.undertow.accesslog.directory=$&#123;log.path&#125;</span><br><span class="line">server.undertow.accesslog.enabled=true</span><br><span class="line">server.undertow.accesslog.pattern=%t %a &quot;%r&quot; %s (%D ms)</span><br></pre></td></tr></table></figure>
<p>其中pattern 常用模式：common、combined</p>
<ul>
<li><strong>common</strong> - <code>%h %l %u %t &quot;%r&quot; %s %b</code></li>
<li><strong>combined</strong> - <code>%h %l %u %t &quot;%r&quot; %s %b &quot;%{i,Referer}&quot; &quot;%{i,User-Agent}&quot;</code></li>
</ul>
<p>自定义pattern：</p>
<p><img src="https://qiaojiande-1259482780.cos.ap-chengdu.myqcloud.com/201908/undertow-access-log-pattern.jpg" alt=""></p>
]]></content>
      <tags>
        <tag>access.log</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis笔记</title>
    <url>/article/Redis%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="redis数据类型">Redis数据类型</h3>
<p>字符串String</p>
<p>Hash表</p>
<p>List列表：</p>
<p>LPUSH + BRPOP 实现消息队列，支持消息持久化，保证消息顺序性；不足的地方：不支持消息的消费确认，不能做广播模式，不能重复消费，不支持分组消费</p>
<p>LPUSH + LPOP 实现栈，先进后出</p>
<p>LPUSH + RPOP 实现队列，先进先出</p>
<p>LPUSH + LTRIM 实现有限队列</p>
<p>Set集合：</p>
<p>数据去重，交集、并集操作，实现共同关注等功能</p>
<p>Sorted Set有序集合：</p>
<p>各类排行榜，范围查找</p>
<p>HyperLogLog：</p>
<p>不精确（0.81%的错误率）的去重统计，比如：网站UV数、访问IP数等</p>
<p>Geo：</p>
<p>Stream：用于实现消息队列（支持消息ID自动生成，消息遍历，消息的阻塞和非阻塞读取，消息的分组消费，消息的消费确认，未完成消息的处理，消息队列监控）参考 <a href="http://www.hellokang.net/redis/stream.html#_10-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88" target="_blank" rel="noopener">http://www.hellokang.net/redis/stream.html#_10-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88</a></p>
<p>Stream底层数据结构Radix树（基数树），可以看作是Trie树（字典树）的变种</p>
<p>基数树（长整型到对象的映射）</p>
<p><img src="https://qiaojiande-1259482780.cos.ap-chengdu.myqcloud.com/201908/%E5%9F%BA%E6%95%B0%E6%A0%91.jpg" alt=""></p>
<p>字典树（字符串到对象的映射）</p>
<p><img src="https://qiaojiande-1259482780.cos.ap-chengdu.myqcloud.com/201908/%E5%AD%97%E5%85%B8%E6%A0%91.jpg" alt=""></p>
<p>PUB/SUB 订阅/发布 （用作消息队列，支持广播模式，支持消息即时推送，支持消费者同时订阅多个信道从而接受多类消息，不足的地方：不支持消息的消费确认，不能重复消费）</p>
<h3 id="redis查看帮助">Redis查看帮助</h3>
<p>命令行下输入help @，再按tab键会提示可以查看help的数据类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help @string</span><br><span class="line">127.0.0.1:6379&gt; help @hash</span><br><span class="line">127.0.0.1:6379&gt; help @list</span><br><span class="line">127.0.0.1:6379&gt; help @set</span><br><span class="line">127.0.0.1:6379&gt; help @sorted_set</span><br><span class="line">127.0.0.1:6379&gt; help @geo</span><br><span class="line">127.0.0.1:6379&gt; help @pubsub</span><br><span class="line">127.0.0.1:6379&gt; help @transactions</span><br><span class="line">127.0.0.1:6379&gt; help @connection</span><br><span class="line">127.0.0.1:6379&gt; help @generic</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux排查问题命令</title>
    <url>/article/Linux%E6%8E%92%E6%9F%A5%E9%97%AE%E9%A2%98%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>线上问题排查时需要从各个方面查看系统的情况，在此列举常用的排查命令，按类别区分如下</p>
<h3 id="系统信息">系统信息</h3>
<p>内核版本信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat /proc/version</span><br><span class="line">uname -a</span><br></pre></td></tr></table></figure>
<p>系统版本信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lsb_release -a</span><br><span class="line">cat /etc/redhat-release</span><br><span class="line">cat /etc/issue</span><br></pre></td></tr></table></figure>
<p>硬盘信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看各分区使用情况</span><br><span class="line">df -ah</span><br><span class="line"># 查看指定目录的大小</span><br><span class="line">du -sh &lt;目录名&gt; </span><br><span class="line"># 查看挂接的分区状态</span><br><span class="line">mount | column -t   </span><br><span class="line"># 查看目录所在的挂载分区</span><br><span class="line">df &lt;目录绝对路径&gt;				 </span><br><span class="line">fdisk -l               # 查看所有分区</span><br><span class="line">swapon -s              # 查看所有交换分区</span><br></pre></td></tr></table></figure>
<p>CPU信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 总核数 = 物理CPU个数 X 每颗物理CPU的核数 </span><br><span class="line"># 总逻辑CPU数 = 物理CPU个数 X 每颗物理CPU的核数 X 超线程数</span><br><span class="line"></span><br><span class="line"># 查看物理CPU个数</span><br><span class="line">cat /proc/cpuinfo| grep &quot;physical id&quot;| sort| uniq| wc -l</span><br><span class="line"></span><br><span class="line"># 查看每个物理CPU中core的个数(即核数)</span><br><span class="line">cat /proc/cpuinfo| grep &quot;cpu cores&quot;| uniq</span><br><span class="line"></span><br><span class="line"># 查看逻辑CPU的个数</span><br><span class="line">cat /proc/cpuinfo| grep &quot;processor&quot;| wc -l</span><br></pre></td></tr></table></figure>
<p>内存信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">free -m</span><br><span class="line">cat /proc/meminfo</span><br></pre></td></tr></table></figure>
<p>系统负载信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uptime</span><br><span class="line">cat /proc/loadavg</span><br><span class="line">tload -d 1 （指定间隔1秒采集一次）</span><br><span class="line">top -c</span><br></pre></td></tr></table></figure>
<p>用户信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat /etc/password</span><br><span class="line"># 文件目录权限</span><br><span class="line">ls -al &lt;文件或目录&gt;</span><br><span class="line">#修改文件或目录权限</span><br><span class="line">#rwx-权限</span><br><span class="line">chmod</span><br><span class="line">#文件所属用户</span><br><span class="line">chown</span><br><span class="line">#文件所属用户组</span><br><span class="line">chgrp</span><br></pre></td></tr></table></figure>
<p>进程信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -ef | grep &lt;pid或者进程名关键字&gt;</span><br><span class="line">ps -ef | grep &lt;pid或者进程名关键字&gt;</span><br><span class="line">top -c</span><br></pre></td></tr></table></figure>
<h3 id="问题排查">问题排查</h3>
<ol>
<li>查看本机host配置</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat /etc/hosts</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>查看服务器主机是否网络可达</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ping ip</span><br><span class="line">pingonline网址，防止dns污染</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>追踪路由信息</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">traceroute</span><br><span class="line">tracepath（不需要root）</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>查看域名解析</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dig</span><br><span class="line">nslookup</span><br><span class="line">host</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>telnet端口连通性</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">telnet 域名/IP port</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>查看当前运行程序</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -ef | grep &lt;pid或者进程名关键字&gt;</span><br><span class="line">ps -ef | grep &lt;pid或者进程名关键字&gt;</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>查看网络连接状态</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat -ntlp</span><br><span class="line">-a: 显示所有listening和非listening中的socket连接</span><br><span class="line">-t: tcp</span><br><span class="line">-n: 显示数字地址</span><br><span class="line">-l: 监听中listening</span><br><span class="line">-p: 显示进程名称和PID</span><br><span class="line"></span><br><span class="line">netstat -anp | grep port/app #因为服务器可能是多网卡配置，绑定地址 127.0.0.1（本机地址） 和 0.0.0.0（无限制） 区别）</span><br></pre></td></tr></table></figure>
<ol start="8">
<li>查看系统打开文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lsof -i :port</span><br></pre></td></tr></table></figure>
<ol start="9">
<li>查看防火墙配置</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables</span><br><span class="line">firewall</span><br><span class="line">#selinux是否关闭</span><br><span class="line">getenforce/sestatus -v:查看selinux状态</span><br><span class="line">setenforce 0:临时关闭selinux</span><br><span class="line">vi /etc/selinux/config: 永久关闭， 需要重启服务器</span><br></pre></td></tr></table></figure>
<ol start="10">
<li>
<p>查看nginx配置和日志</p>
</li>
<li>
<p>查看web容器 - access log</p>
</li>
<li>
<p>查看应用日志</p>
</li>
<li>
<p>抓包工具：charles、wireshark</p>
</li>
</ol>
<h3 id="cpu满负载问题">CPU满负载问题</h3>
<ol>
<li>找出消耗cpu最高的进程PID<br>
top -c	（显示进程运行信息列表，默认CPU使用率排序）</li>
<li>根据PID查出消耗cpu最高的线程号<br>
top -Hp pid （显示一个进程的线程运行信息列表，默认CPU使用率排序）<br>
2.1 线程id十进制转16进制：<br>
printf “%x\n” xxoo</li>
<li>导出进程快照<br>
jstack -l pid &gt; pid.stack</li>
<li>根据线程号查出对应的java线程，进行处理<br>
cat pid.stack | grep ‘十六进制线程号’ -C 10</li>
</ol>
<p>jps -l 输出java进程pid-进程名信息<br>
top -Hp pid 输出指定java进程线程消耗cpu排行<br>
jstack -l pid 导出java进程的堆栈信息</p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>godaddy域名+cloudflare_CDN+v2ray+caddy纪实</title>
    <url>/article/godaddy%E5%9F%9F%E5%90%8D-cloudflare-CDN-v2ray-caddy%E7%BA%AA%E5%AE%9E/</url>
    <content><![CDATA[<p>祖国70大寿临近，网络安全升级，vps被封。此时我只想高歌一曲：我爱你，中国。。。</p>
<p><img src="https://qiaojiande-1259482780.cos.ap-chengdu.myqcloud.com/201908/pingpe-test.jpg" alt=""></p>
<p>用 <a href="http://ping.pe/ping.php" target="_blank" rel="noopener">http://ping.pe/ping.php</a> ping一下你的vps，如果国内的节点100%loss，国外节点可正常访问，即说明IP被封了。此时直接通过vps搭建v2ray或ss翻墙已经行不通了。</p>
<p>参考网上资料通过域名+CDN+v2ray的方式成功实现翻墙，步骤如下：</p>
<h2 id="godaddy购买域名">godaddy购买域名</h2>
<ol>
<li>
<p>注册账号</p>
</li>
<li>
<p>选购域名</p>
</li>
<li>
<p>配置域名服务器，此处要填写cloudflare中的域名服务器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bella.ns.cloudflare.com</span><br><span class="line">carter.ns.cloudflare.com</span><br></pre></td></tr></table></figure>
<p><img src="https://qiaojiande-1259482780.cos.ap-chengdu.myqcloud.com/201908/godaddy-dnsserver.jpg" alt=""></p>
</li>
</ol>
<h2 id="cloudflare添加域名">cloudflare添加域名</h2>
<ol>
<li>
<p>注册账号</p>
</li>
<li>
<p>添加网址</p>
<p><img src="https://qiaojiande-1259482780.cos.ap-chengdu.myqcloud.com/201908/cloudflare-addsite.jpg" alt=""></p>
</li>
<li>
<p>到域名购买商网站配置域名服务器，配置成cloudflare的域名服务器（即上一步骤-3）</p>
</li>
<li>
<p>选择DNS选项卡，添加A记录配置域名DNS解析到VPS IP地址 （在DNS选项卡里确保云朵图标是灰色）</p>
</li>
<li>
<p>选择SSL/TLS选项卡，选择SSL/TLS模式为Full(strict)</p>
</li>
<li>
<p>选择SSL/TLS选项卡，选择Origin Server子选项卡，点击Creat Certificate，创建免费证书，此时会生成两个密文，复制上面的到vps服务器保存为xxx.pem，复制下面的到vps服务器xxx.key。由于caddy向Let’s Encrypt签名证书总是失败，我们后面会使用自签名证书，指定的 证书即为这儿的xxx.pem，证书key即为这儿的xxx.key</p>
</li>
<li>
<p>cloudflare的配置至此告一段落，然后移步至vps服务器配置v2ray和caddy，配置运行OK后，回到cloudflare，选择DNS选项卡，将云朵图标点亮为橙色（DNS Proxy，此时域名会被解析到cloudflare的IP，cloudflare会做转发到我们真正的VPS IP 地址）</p>
</li>
</ol>
<h2 id="v2ray管理脚本">v2ray管理脚本</h2>
<ol>
<li>
<p>运行v2ray管理脚本一键安装脚本： bash &lt;(curl -s -L <a href="https://233blog.com/v2ray.sh" target="_blank" rel="noopener">https://233blog.com/v2ray.sh</a>)</p>
</li>
<li>
<p>运行v2ray命令，运行v2ray管理脚本，修改协议（选项2）为：websocket + tls（选项4），然后会提示输入域名，此时要确保域名解析到VPS IP 地址。一路默认，会安装caddy反向代理，但是caddy自动tls证书申请失败</p>
</li>
<li>
<p>此时运行v2ray status 查看v2ray和caddy运行状态都未运行</p>
</li>
<li>
<p>手动运行v2ray： v2ray --config=/etc/v2ray/config.json &amp;</p>
</li>
<li>
<p>手动运行caddy：首先使用自签名证书，证书是cloudflare提供的免费证书，将xxx.pem、xxx.key复制到/etc/ssl/caddy目录下，配置/etc/caddy/Caddyfile：指定tls证书和key，指定https端口443，systemctl start caddy运行caddy</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xxx.com:443 &#123;</span><br><span class="line">    tls /etc/ssl/caddy/xxx.pem /etc/ssl/caddy/xxx.key</span><br><span class="line">    timeouts none</span><br><span class="line">    #33334 是v2ray inbound监听的端口</span><br><span class="line">    proxy / 127.0.0.1:33334 &#123;</span><br><span class="line">	websocket</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>一定注意</strong>：之前使用ufw控制防火墙，ufw allow 443，但是telnet 还是不通。建议直接关掉防火墙后即可。</p>
</li>
<li>
<p>至此，服务器配置完成，然后移步cloudflare，将DNS选项卡的云朵点亮</p>
</li>
<li>
<p>v2ray info 查看v2ray配置，客户端v2ray据此配置即可</p>
<p><img src="https://qiaojiande-1259482780.cos.ap-chengdu.myqcloud.com/201908/v2rayconfig.jpg" alt=""></p>
</li>
</ol>
<h2 id="分割线">分割线</h2>
<p>靠，终于又可以用google了。。。</p>
]]></content>
      <tags>
        <tag>v2ray</tag>
      </tags>
  </entry>
  <entry>
    <title>java-字符串</title>
    <url>/article/java-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>Java字符串表示方式有三种：</p>
<ol>
<li>
<p>字符串常量，以双引号括起来的内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String literialStr = “字符串常量”;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>字符数组，以单引号括起来的内容表示一个字符，多个连以来表示字符串，String内部就是用字符数组来表示的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>[] chars = &#123;<span class="string">'字'</span>, <span class="string">'符'</span>, <span class="string">'串'</span>, <span class="string">'常'</span>, <span class="string">'量'</span>&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>String实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String strs = <span class="keyword">new</span> String(<span class="string">"字符串常量"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>字符串特性：</p>
<ol>
<li>
<p>比较，使用==比较的是两个字符串是否引用同一个对象；使用equals比较两个字符串内容是否相等</p>
</li>
<li>
<p>StringBuilder（多线程不安全）和StringBuffer（多线程安全）的toString方法返回的是new String(&quot;…&quot;)</p>
</li>
<li>
<p>字符串常量池，javap -verbose ClassName，反编译类后可以看到一个java文件被编译成class文件后的结构和内容。其中有一项结构是Constant pool（常量池），它里面会保存此class文件用到的所有常量包括类名、方法名、字符串常量。当class文件被载入jvm运行时，字符串常量池也会相应的载入内存成为运行时常量池。个人理解类似程序和进程的概念，一种是静态的描述，一种是载入内存后动态的表示。</p>
</li>
<li>
<p>intern方法，查看JDK文档，关注重点：</p>
<ol>
<li>调用intern方法时，会从字符串常量池去找，如果找到（通过equals方法判断），直接返回字符串常量池的引用</li>
<li>没有找到，则会将此String对象加入字符串常量池（字符串常量池此时将建立一个执行堆内存String对象的引用），然后还是返回字符串常量池的引用（注意：此时字符串常量池的引用指向堆内存的String对象）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a canonical representation for the string object.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * A pool of strings, initially empty, is maintained privately by the</span></span><br><span class="line"><span class="comment">     * class &#123;<span class="doctag">@code</span> String&#125;.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * When the intern method is invoked, if the pool already contains a</span></span><br><span class="line"><span class="comment">     * string equal to this &#123;<span class="doctag">@code</span> String&#125; object as determined by</span></span><br><span class="line"><span class="comment">     * the &#123;<span class="doctag">@link</span> #equals(Object)&#125; method, then the string from the pool is</span></span><br><span class="line"><span class="comment">     * returned. Otherwise, this &#123;<span class="doctag">@code</span> String&#125; object is added to the</span></span><br><span class="line"><span class="comment">     * pool and a reference to this &#123;<span class="doctag">@code</span> String&#125; object is returned.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * It follows that for any two strings &#123;<span class="doctag">@code</span> s&#125; and &#123;<span class="doctag">@code</span> t&#125;,</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> s.intern() == t.intern()&#125; is &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment">     * if and only if &#123;<span class="doctag">@code</span> s.equals(t)&#125; is &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * All literal strings and string-valued constant expressions are</span></span><br><span class="line"><span class="comment">     * interned. String literals are defined in section 3.10.5 of the</span></span><br><span class="line"><span class="comment">     * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  a string that has the same contents as this string, but is</span></span><br><span class="line"><span class="comment">     *          guaranteed to be from a pool of unique strings.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">intern</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>下面，基于intern的处理逻辑，看看几个例子</p>
<p>第一个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先，将"string_test_1"存入字符串常量池，然后在堆上创建一个String对象，并返回堆上String对象的引用</span></span><br><span class="line">String s = <span class="keyword">new</span> String(<span class="string">"string_test_1"</span>); </span><br><span class="line"><span class="comment">//调用intern方法，发现字符串常量池里已有“string_test_1”，返回字符串常量池对象的引用</span></span><br><span class="line">s.intern();</span><br><span class="line"><span class="comment">//字符串常量池已有“string_test_1”，返回字符串常量池的引用</span></span><br><span class="line">String s2 = <span class="string">"string_test_1"</span>;</span><br><span class="line">System.out.println(s == s2); <span class="comment">//堆上String对象引用 不等于 字符串常量池对象引用，结果为false</span></span><br></pre></td></tr></table></figure>
<p>第二个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//直接在堆上创建一个String对象，并返回堆上String对象的引用</span></span><br><span class="line">String s3 = <span class="keyword">new</span> StringBuilder().append ( <span class="string">"string_"</span> ).append ( <span class="string">"test_2"</span> ).toString ();</span><br><span class="line"><span class="comment">//调用intern方法，发现字符串常量池里还没有“string_test_2”，将在字符串常量池创建一个引用指向堆上String对象</span></span><br><span class="line">s3.intern();</span><br><span class="line"><span class="comment">//字符串常量池已有指向堆上String对象的引用，equals判等，返回字符串常量池的引用（指向堆上String对象）</span></span><br><span class="line">String s4 = <span class="string">"string_test_2"</span>;</span><br><span class="line">System.out.println(s3 == s4); <span class="comment">//堆上String对象引用 等于 字符串常量池的引用 结果为true</span></span><br></pre></td></tr></table></figure>
<p>第三个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先，将"first"存入字符串常量池，并返回字符串常量池里String对象的引用</span></span><br><span class="line">String s1 = <span class="string">"same1"</span>;</span><br><span class="line"><span class="comment">//字符串常量池已有“same”，返回字符串常量池里的String对象引用</span></span><br><span class="line">String s2 = <span class="string">"same1"</span>;</span><br><span class="line">System.out.println(s1 == s2); <span class="comment">//s1、s2同为字符串常量池里的String对象引用，结果为true</span></span><br></pre></td></tr></table></figure>
<p>第四个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先，将"same2"存入字符串常量池，然后在堆上创建一个String对象，并返回堆上String对象的引用</span></span><br><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"same2"</span>);</span><br><span class="line"><span class="comment">//字符串常量池已有“same2”，返回字符串常量池里的String对象引用</span></span><br><span class="line">String s2 = <span class="string">"same2"</span>;</span><br><span class="line">System.out.println(s1 == s2); <span class="comment">//堆上String对象引用 不等于 字符串常量池对象引用，结果为false</span></span><br></pre></td></tr></table></figure>
<p>第五个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将"first"存入字符串常量池，并返回字符串常量池里String对象的引用</span></span><br><span class="line">String s1 = <span class="string">"first"</span>;</span><br><span class="line"><span class="comment">//将"second"存入字符串常量池，并返回字符串常量池里String对象的引用</span></span><br><span class="line">String s2 = <span class="string">"second"</span>;</span><br><span class="line"><span class="comment">//将"firstsecond"存入字符串常量池，并返回字符串常量池里String对象的引用</span></span><br><span class="line">String s3 = <span class="string">"firstsecond"</span>;</span><br><span class="line"><span class="comment">//s1+s2是调用StringBuilder返回一个new String对象引用，在堆上</span></span><br><span class="line">String s4 = s1 + s2;</span><br><span class="line"><span class="comment">//字符串常量相加，在编译期替换成“firstsecond”，从字符串常量池查找并返回字符串常量池里String对象的引用</span></span><br><span class="line">String s5 = <span class="string">"first"</span> + <span class="string">"second"</span>;</span><br><span class="line">System.out.println(s3 == s4); <span class="comment">// false</span></span><br><span class="line">System.out.println(s3 == s5); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>第六个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> String s1 = <span class="string">"first"</span>;</span><br><span class="line"><span class="keyword">final</span> String s2 = <span class="string">"second"</span>;</span><br><span class="line">String s3 = <span class="string">"firstsecond"</span>;</span><br><span class="line"><span class="comment">//s1、s2被final修饰后，在编译期被替换成字符串常量相加，得到“firstsecond”，从字符串常量池查找并返回字符串常量池里String对象的引用</span></span><br><span class="line">String s4 = s1 + s2;</span><br><span class="line">String s5 = <span class="string">"first"</span> + <span class="string">"second"</span>;</span><br><span class="line">System.out.println(s3 == s4); <span class="comment">// true</span></span><br><span class="line">System.out.println(s3 == s5); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>java String</tag>
      </tags>
  </entry>
  <entry>
    <title>java-注解</title>
    <url>/article/java-%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<p>探究java注解底层实现原理，首先自定义一个注解类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyTypeAnnotation &#123;</span><br><span class="line">   <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再定义个main函数类来使用该注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MyTypeAnnotation</span>(name=<span class="string">"Test"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMyTypeAnnotation</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		MyTypeAnnotation type = TestMyTypeAnnotation.class.getAnnotation(MyTypeAnnotation.class);</span><br><span class="line">		System.out.println(type.name());</span><br><span class="line">		System.in.read(); <span class="comment">//waiting...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行javac *.java编译成class文件，通过javap查看字节码可知：注解是一种继承自接口<code>java.lang.annotation.Annotation</code>的特殊接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[qiaojian<span class="meta">@Mac</span> testannotation ]% javap MyTypeAnnotation                                     [<span class="number">0</span>]</span><br><span class="line">Compiled from <span class="string">"MyTypeAnnotation.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyTypeAnnotation</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">annotation</span>.<span class="title">Annotation</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> java.lang.<span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口是怎么直接使用的呢？还是通过java中万能的动态代理实现的，动态代理会在运行时生成一个实现了MyTypeAnnotation接口的类实例，并设置上我们配置的注解属性值，然后通过反射获取。我们可以通过加上运行参数-Dsun.misc.ProxyGenerator.saveGeneratedFiles=true生成动态代理类class文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[qiaojian<span class="meta">@Mac</span> testannotation ]% java -Dsun.misc.ProxyGenerator.saveGeneratedFiles=<span class="keyword">true</span> TestMyTypeAnnotation</span><br><span class="line">Test</span><br><span class="line">^C%                                                                                            [qiaojian<span class="meta">@Mac</span> testannotation ]% ls                                                       [<span class="number">130</span>]</span><br><span class="line">MyTypeAnnotation.class     TestMyTypeAnnotation.class com</span><br><span class="line">MyTypeAnnotation.java      TestMyTypeAnnotation.java</span><br><span class="line">[qiaojian<span class="meta">@Mac</span> testannotation ]% ls com/sun/proxy/com/                                      [<span class="number">0</span>]</span><br><span class="line">\$Proxy0.class  \$Proxy1.class  com/</span><br></pre></td></tr></table></figure>
<p>反编译查看class文件可知：生成的代理类实现了MyTypeAnnotation接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[qiaojian<span class="meta">@Mac</span> proxy ]% javap \$Proxy1                                                      [<span class="number">0</span>]</span><br><span class="line">Warning: Binary file $Proxy1 contains com.sun.proxy.$Proxy1</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">sun</span>.<span class="title">proxy</span>.$<span class="title">Proxy1</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">reflect</span>.<span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">MyTypeAnnotation</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> com.sun.proxy.$Proxy1(java.lang.reflect.InvocationHandler);</span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> java.lang.<span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(java.lang.Object)</span></span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> java.lang.<span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> java.lang.<span class="function">Class <span class="title">annotationType</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，我们可以通过HotSpot DeBuger工具来实时查看一下注解的实现和值是否和我们预期一样</p>
<p>首先，执行java，将程序跑起来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[qiaojian<span class="meta">@Mac</span> testannotation ]% java TestMyTypeAnnotation                                           [<span class="number">0</span>]</span><br><span class="line">Test</span><br></pre></td></tr></table></figure>
<p>然后ps查看进程ID：88954</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[qiaojian<span class="meta">@Mac</span> testannotation ]% psfind TestMyTypeAnnotation                                         [<span class="number">0</span>]</span><br><span class="line">  PID TTY           TIME CMD</span><br><span class="line"><span class="number">88954</span> ttys001    <span class="number">0</span>:<span class="number">00.21</span> /usr/bin/java TestMyTypeAnnotation</span><br><span class="line"><span class="number">88965</span> ttys002    <span class="number">0</span>:<span class="number">00.00</span> grep --color --color=auto TestMyTypeAnnotation</span><br></pre></td></tr></table></figure>
<p>打开HSDB</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[qiaojian<span class="meta">@Mac</span> testannotation ]% sudo java -cp /Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/lib/sa-jdi.jar sun.jvm.hotspot.HSDB</span><br><span class="line">Password:</span><br></pre></td></tr></table></figure>
<p>attach 进程ID</p>
<p><img src="https://qiaojiande-1259482780.cos.ap-chengdu.myqcloud.com/201908/annotation-attach-pid.jpg" alt=""></p>
<p>查看堆内存参数</p>
<p><img src="https://qiaojiande-1259482780.cos.ap-chengdu.myqcloud.com/201908/annotation-heap-param.jpg" alt=""></p>
<p>查看注解的实现类实例</p>
<p><img src="https://qiaojiande-1259482780.cos.ap-chengdu.myqcloud.com/201908/annotation-proxy-inst.jpg" alt=""></p>
<p>查看注解属性的设置值</p>
<p><img src="https://qiaojiande-1259482780.cos.ap-chengdu.myqcloud.com/201908/annotation-inspect-value.jpg" alt=""></p>
<p>使用HSDB可以方便的查看java 进程的运行时数据状态，方便debug</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java-线程池</title>
    <url>/article/java-%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h3 id="什么是线程池">什么是线程池</h3>
<p>线程池 = worker线程 + 任务队列</p>
<h3 id="worker线程">worker线程</h3>
<p>继承自AQS，并且实现了Runnable接口。worker线程不断从任务队列里获取任务并执行，当任务队列里面没有任务可执行了或者任务执行途中抛出异常时，线程退出，销毁线程。</p>
<h4 id="aqs">AQS</h4>
<p>AQS为那些基于FIFO等待队列的同步器和阻塞锁提供了一个框架<br>
AQS为那些用单个原子int值表示状态的同步器，提供了状态的原子操作（getState、setState、compareAndSetState）<br>
同步器要继承自AQS，并作为非public的内部helper类，具体的public同步方法由外围包装类提供<br>
AQS支持互斥、共享两种获取锁的模式，子类同步器一般实现其中一种模式，也可以实现两种模式供用户选择，如ReadWriteLock<br>
AQS定义了嵌套类ConditionObject 实现了Condition接口，支持互斥模式的子类同步器可以使用此对象来实现Object内置的wait-notify语义<br>
子类同步器需要实现以下方法，且要保证实现方法的线程安全，修改或者获取状态使用AQS提供的方法getState、setState、compareAndSetState<br>
tryAcquire<br>
tryRelease<br>
tryAcquireShared<br>
tryReleaseShared<br>
isHeldExclusively</p>
<p>AQS内部的FIFO队列的使用方式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Acquire:</span><br><span class="line">    while (!tryAcquire(arg)) &#123; //尝试获取锁</span><br><span class="line">        enqueue thread if it is not already queued; //获取失败则，将当前线程入队列</span><br><span class="line">        possibly block current thread; //当前线程在FIFO队列阻塞等待</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Release:</span><br><span class="line">    if (tryRelease(arg)) //尝试释放锁</span><br><span class="line">        unblock the first queued thread; //释放成功则，将FIFO队首线程出队列</span><br></pre></td></tr></table></figure>
<p>如果AQS不能满足你的同步器需求，你可以基于更底层的java.util.concurrent.atomic类、java.util.Queue类和LockSupport类来实现自定义的同步器</p>
<p>AQS使用举例：<br>
Mutex类：互斥锁，状态0代表unlock，状态1代表locked</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 内部Helper类继承自 AQS</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查看锁是否已被占用</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取锁，将state由 0 修改为 1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">assert</span> acquires == <span class="number">1</span>; <span class="comment">// Otherwise unused</span></span><br><span class="line">      <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放锁，将state由 1 修改为 0</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">assert</span> releases == <span class="number">1</span>; <span class="comment">// Otherwise unused</span></span><br><span class="line">      <span class="keyword">if</span> (getState() == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">      setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">      setState(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供Conditon接口实现等待通知机制</span></span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Deserializes properly</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">      s.defaultReadObject();</span><br><span class="line">      setState(<span class="number">0</span>); <span class="comment">// reset to unlocked state</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 属性实例化同步器（初始化线程安全），并将同步器置为final（操作线程安全）</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 外围包装类Mutex提供用户使用接口</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>                </span>&#123; sync.acquire(<span class="number">1</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>          </span>&#123; <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>              </span>&#123; sync.release(<span class="number">1</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> sync.newCondition(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span>         </span>&#123; <span class="keyword">return</span> sync.isHeldExclusively(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> sync.hasQueuedThreads(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CLH队列：基于链表的确保无饥饿的、提供先来先服务的，公平的自旋锁，申请线程只在本地变量上自旋，它【不断轮询前驱的状态，如果发现前驱释放了锁就结束自旋，获得锁】<br>
当一个线程获取锁时：<br>
1. 创建Node节点：封装线程+状态，状态置为：获取锁， 加入FIFO队列队尾<br>
2. 获取队列里的前驱节点，自旋检查前驱节点的状态，直到前驱节点状态为：释放锁 时，自己获取到锁，并回收前驱节点</p>
<p>当一个线程释放锁时：<br>
1. 释放锁的节点必然是队列头节点，设置自己的状态为：释放锁</p>
<p>等待队列：CLH队列的变种 用于阻塞同步<br>
当一个线程获取锁时： 没获取到，会加入队尾，并且使用LockSupport.park 阻塞当前线程，进入睡眠状态</p>
<p>当上一个节点释放锁时，使用LockSupport.unpark 去通知后继节点，唤醒相应的线程</p>
<h3 id="任务队列">任务队列</h3>
<p>任务队列实现BlockingQueue接口，细分为：</p>
<p>无界队列：DelayedWorkQueue、LinkedBlockingQueue</p>
<p>有界队列：ArrayBlockingQueue</p>
<p>直接递交给worker线程型队列（队列不存放任务）：SynchronousQueue</p>
<h3 id="线程池中的位运算">线程池中的位运算</h3>
<p><img src="https://qiaojiande-1259482780.cos.ap-chengdu.myqcloud.com/201908/threadpool-bit-operation.jpg" alt=""></p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java沙箱</title>
    <url>/article/java%E6%B2%99%E7%AE%B1/</url>
    <content><![CDATA[<p>参考文档1：<a href="https://www.zybuluo.com/changedi/note/237999" target="_blank" rel="noopener">https://www.zybuluo.com/changedi/note/237999</a></p>
<p>参考文档2：<a href="https://benjaminwhx.com/2018/06/19/AccessController-doPrivileged/" target="_blank" rel="noopener">https://benjaminwhx.com/2018/06/19/AccessController-doPrivileged/</a></p>
<p>起因是在学习JDBC驱动加载机制(SPI-接口与实现分离，实现解耦，参考文档：<a href="https://juejin.im/post/5b9b1c115188255c5e66d18c" target="_blank" rel="noopener">https://juejin.im/post/5b9b1c115188255c5e66d18c</a>)的时候碰到如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  drivers = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;String&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> System.getProperty(<span class="string">"jdbc.drivers"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">  drivers = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大意是通过<code>特权</code>的方式突破当前域权限的限制，临时扩大访问权限，获取系统资源。</p>
<p>这是为了在开启java的沙箱机制的程序中获得执行代码的权限。java沙箱机制参考以上文档介绍。</p>
<p>运行java程序时默认是不开启沙箱机制的，要开启沙箱机制加入启动参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Djava.security.manager</span><br></pre></td></tr></table></figure>
<p>开启沙箱机制后，java的安全管理器SecurityManager即起作用了，安全管理器会去读策略文件来判断java类的执行权限，默认的策略文件<code>$JREHOME/lib/security/java.policy</code>，可以命令行参数指定策略文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Djava.security.policy=xx.policy</span><br></pre></td></tr></table></figure>
<p>下面通过一个创建文件的例子来说明开启沙箱后的权限验证和AccessController.doPrivileged的特权作用</p>
<blockquote>
<ol>
<li>vim FileUtil.java</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">package</span> com.leo.security;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">import</span> java.io.File;</span><br><span class="line">&gt; <span class="keyword">import</span> java.io.IOException;</span><br><span class="line">&gt; <span class="keyword">import</span> java.security.AccessControlException;</span><br><span class="line">&gt; <span class="keyword">import</span> java.security.AccessController;</span><br><span class="line">&gt; <span class="keyword">import</span> java.security.PrivilegedAction;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt;  *</span></span><br><span class="line"><span class="comment">&gt;  */</span></span><br><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUtil</span> </span>&#123;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String FOLDER_PATH = <span class="string">"/Users/qiaojian/Downloads/"</span>;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">makeFile</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">&gt;         <span class="keyword">try</span> &#123;</span><br><span class="line">&gt;             File fs = <span class="keyword">new</span> File(FOLDER_PATH + fileName);</span><br><span class="line">&gt;             fs.createNewFile();</span><br><span class="line">&gt;         &#125; <span class="keyword">catch</span> (AccessControlException | IOException e) &#123;</span><br><span class="line">&gt;             e.printStackTrace();</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doPrivilegedAction</span><span class="params">(<span class="keyword">final</span> String fileName)</span> </span>&#123;</span><br><span class="line">&gt;         <span class="comment">// 用特权访问方式创建文件</span></span><br><span class="line">&gt;         AccessController.doPrivileged( <span class="keyword">new</span> PrivilegedAction&lt;String&gt; () &#123;</span><br><span class="line">&gt;             <span class="meta">@Override</span></span><br><span class="line">&gt;             <span class="function"><span class="keyword">public</span> String <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;                 makeFile(fileName);</span><br><span class="line">&gt;                 <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&gt;             &#125;</span><br><span class="line">&gt;         &#125;);</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<ol start="2">
<li>将此java文件打包成一个项目jar包</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span> [qiaojian@Mac security ]% mkdir target</span><br><span class="line"><span class="meta">&gt;</span> [qiaojian@Mac security ]% javac FileUtil.java -d target</span><br><span class="line"><span class="meta">&gt;</span> [qiaojian@Mac security ]% jar cvf file-util.jar -C target/ .</span><br><span class="line"><span class="meta">&gt;</span> #将此jar包放到lib目录下供其他项目使用</span><br><span class="line"><span class="meta">&gt;</span> [qiaojian@Mac security ]% mkdir lib</span><br><span class="line"><span class="meta">&gt;</span> [qiaojian@Mac security ]% mv file-util.jar lib/</span><br><span class="line"><span class="meta">&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<ol start="3">
<li>vim PrivilegeTest.java</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">package</span> com.leo.security;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">import</span> java.io.File;</span><br><span class="line">&gt; <span class="keyword">import</span> java.io.IOException;</span><br><span class="line">&gt; <span class="keyword">import</span> java.security.AccessControlException;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt;  *</span></span><br><span class="line"><span class="comment">&gt;  */</span></span><br><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivilegeTest</span> </span>&#123;</span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">&gt;         System.out.println(<span class="string">"***************************************"</span>);</span><br><span class="line">&gt;         System.out.println(<span class="string">"I will show AccessControl functionality..."</span>);</span><br><span class="line">&gt; </span><br><span class="line">&gt;         System.out.println(<span class="string">"Preparation step : turn on system permission check..."</span>);</span><br><span class="line">&gt;         <span class="comment">// 打开系统安全权限检查开关，添加vm options: -Djava.security.manager</span></span><br><span class="line">&gt;         <span class="comment">// 使用特定policy，添加vm options: -Djava.security.policy=privilegetest.policy</span></span><br><span class="line">&gt;         System.out.println();</span><br><span class="line">&gt; </span><br><span class="line">&gt;         System.out.println(<span class="string">"#########################################"</span>);</span><br><span class="line">&gt;         System.out.println(<span class="string">"Create a new file named privilege1.txt via privileged action ..."</span>);</span><br><span class="line">&gt;         FileUtil.doPrivilegedAction(<span class="string">"privilege1.txt"</span>);</span><br><span class="line">&gt;         System.out.println(<span class="string">"#########################################"</span>);</span><br><span class="line">&gt; </span><br><span class="line">&gt;         System.out.println();</span><br><span class="line">&gt; </span><br><span class="line">&gt;         System.out.println(<span class="string">"/////////////////////////////////////////"</span>);</span><br><span class="line">&gt;         System.out.println(<span class="string">"Create a new file named privilege2.txt via File ..."</span>);</span><br><span class="line">&gt;         <span class="keyword">try</span> &#123;</span><br><span class="line">&gt;             File fs = <span class="keyword">new</span> File (</span><br><span class="line">&gt;                     <span class="string">"/Users/qiaojian/Downloads/privilege2.txt"</span>);</span><br><span class="line">&gt;             fs.createNewFile();</span><br><span class="line">&gt;         &#125; <span class="keyword">catch</span> (IOException | AccessControlException e) &#123;</span><br><span class="line">&gt;             e.printStackTrace();</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;         System.out.println(<span class="string">"/////////////////////////////////////////"</span>);</span><br><span class="line">&gt;         System.out.println();</span><br><span class="line">&gt; </span><br><span class="line">&gt;         System.out.println(<span class="string">"-----------------------------------------"</span>);</span><br><span class="line">&gt;         System.out.println(<span class="string">"create a new file named privilege3.txt via FileUtil ..."</span>);</span><br><span class="line">&gt;         FileUtil.makeFile(<span class="string">"privilege3.txt"</span>);</span><br><span class="line">&gt;         System.out.println(<span class="string">"-----------------------------------------"</span>);</span><br><span class="line">&gt;         System.out.println();</span><br><span class="line">&gt; </span><br><span class="line">&gt;         System.out.println(<span class="string">"***************************************"</span>);</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<ol start="4">
<li>将此java文件打包成另一个项目jar包</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span> #清空target目录，重新编译PrivilegeTest.java</span><br><span class="line"><span class="meta">&gt;</span> [qiaojian@Mac security ]% cd target;  </span><br><span class="line"><span class="meta">&gt;</span> [qiaojian@Mac security ]% rm -rf *;</span><br><span class="line"><span class="meta">&gt;</span> [qiaojian@Mac security ]% cd ..</span><br><span class="line"><span class="meta">&gt;</span> [qiaojian@Mac security ]% javac -cp lib/file-util.jar PrivilegeTest.java -d target</span><br><span class="line"><span class="meta">&gt;</span> #打包并指定Main-Class所在类</span><br><span class="line"><span class="meta">&gt;</span> [qiaojian@Mac security ]% jar cvfe privilege-test.jar com.leo.security.PrivilegeTest -C target/ .</span><br><span class="line"><span class="meta">&gt;</span> #修改META-INF/MANIFEST.MF，添加Class-Path: lib/file-util.jar</span><br><span class="line"><span class="meta">&gt;</span> [qiaojian@Mac security ]% vim privilege-test.jar</span><br><span class="line"><span class="meta">&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<ol start="5">
<li>编辑自定义策略文件，授权只有项目file-util.jar可以写文件到指定目录</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span> [qiaojian@Mac security ]% vim privilegetest.policy</span><br><span class="line"><span class="meta">&gt;</span> [qiaojian@Mac security ]% cat privilegetest.policy                                         [0]</span><br><span class="line"><span class="meta">&gt;</span> grant codeBase "file:/Users/qiaojian/Downloads/Test/testmybatis/src/main/java/com/leo/security/lib/-" &#123;</span><br><span class="line"><span class="meta">&gt;</span>     permission java.io.FilePermission "/Users/qiaojian/Downloads/*", "write";</span><br><span class="line"><span class="meta">&gt;</span> &#125;;</span><br><span class="line"><span class="meta">&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<ol start="6">
<li>运行程序，指定开启沙箱机制，指定策略文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; java -Djava.security.manager -Djava.security.policy=privilegetest.policy -jar privilege-test.jar</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>从输出可见，项目privilege-test.jar只有通过AccessController.doPrivileged 方式才可以成功创建文件privilege1.txt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; ***************************************</span><br><span class="line">&gt; I will show AccessControl functionality...</span><br><span class="line">&gt; Preparation step : turn on system permission check...</span><br><span class="line">&gt; </span><br><span class="line">&gt; #########################################</span><br><span class="line">&gt; Create a new file named privilege1.txt via privileged action ...</span><br><span class="line">&gt; #########################################</span><br><span class="line">&gt; </span><br><span class="line">&gt; /////////////////////////////////////////</span><br><span class="line">&gt; Create a new file named privilege2.txt via File ...</span><br><span class="line">&gt; java.security.AccessControlException: access denied (&quot;java.io.FilePermission&quot; &quot;/Users/qiaojian/Downloads/privilege2.txt&quot; &quot;write&quot;)</span><br><span class="line">&gt; 	at java.security.AccessControlContext.checkPermission(AccessControlContext.java:472)</span><br><span class="line">&gt; 	at java.security.AccessController.checkPermission(AccessController.java:884)</span><br><span class="line">&gt; 	at java.lang.SecurityManager.checkPermission(SecurityManager.java:549)</span><br><span class="line">&gt; 	at java.lang.SecurityManager.checkWrite(SecurityManager.java:979)</span><br><span class="line">&gt; 	at java.io.File.createNewFile(File.java:1008)</span><br><span class="line">&gt; 	at com.leo.security.PrivilegeTest.main(PrivilegeTest.java:31)</span><br><span class="line">&gt; /////////////////////////////////////////</span><br><span class="line">&gt; </span><br><span class="line">&gt; -----------------------------------------</span><br><span class="line">&gt; create a new file named privilege3.txt via FileUtil ...</span><br><span class="line">&gt; java.security.AccessControlException: access denied (&quot;java.io.FilePermission&quot; &quot;/Users/qiaojian/Downloads/privilege3.txt&quot; &quot;write&quot;)</span><br><span class="line">&gt; 	at java.security.AccessControlContext.checkPermission(AccessControlContext.java:472)</span><br><span class="line">&gt; 	at java.security.AccessController.checkPermission(AccessController.java:884)</span><br><span class="line">&gt; 	at java.lang.SecurityManager.checkPermission(SecurityManager.java:549)</span><br><span class="line">&gt; 	at java.lang.SecurityManager.checkWrite(SecurityManager.java:979)</span><br><span class="line">&gt; 	at java.io.File.createNewFile(File.java:1008)</span><br><span class="line">&gt; 	at com.leo.security.FileUtil.makeFile(FileUtil.java:19)</span><br><span class="line">&gt; 	at com.leo.security.PrivilegeTest.main(PrivilegeTest.java:40)</span><br><span class="line">&gt; -----------------------------------------</span><br><span class="line">&gt; </span><br><span class="line">&gt; ***************************************</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
]]></content>
      <tags>
        <tag>AccessController.doPrivileged</tag>
      </tags>
  </entry>
  <entry>
    <title>梦</title>
    <url>/article/%E6%A2%A6/</url>
    <content><![CDATA[<p><img src="https://qiaojiande-1259482780.cos.ap-chengdu.myqcloud.com/dream.jpg" alt="dream"></p>
<p>前些天晚上（2019-07-03）鬼压床经历（逻辑混乱，但是把我吓惨了）:</p>
<ol>
<li>像是在小时候老家，放学回家，发现爸妈都不在家，到处打电话没人接。等到很晚，妈才从地里干农活回来，我生气的责备她，啷个不接电话，又问她爸呢，她说不出个所以然。我还是有点生气，还有点奇怪和往常不一样，于是在屋里里转悠一圈，发现前两天还在猪圈里的猪不见了。</li>
<li>猪不见了，妈没告诉我，那时候乡下有偷猪的，因为猪圈一般离正房比较远不易被发觉。我以为养了那么大的猪突然被偷了妈她伤心，也怕我伤心就没告诉我。</li>
<li>查猪不见了，线索出现在我开了个不知是电信还是联通移动的的服务器，很神奇，我也不知道咋从这儿开始，手机上看服务器的日志发现头天晚上半夜两点有个手机号运猪出关的记录。不要问逻辑对不对，我能想起的就是这样。</li>
<li>于是去找运营商服务员查询当晚半夜两点的记录，果然发现有个手机号运猪出关的记录，又让服务员查这个手机号对应的人，终于知道是谁了。</li>
<li>他是外国来我们村打工一个小伙，很擅长炒菜，剧情精彩开始了，一开始他也就炒炒菜，有天他发现他跟另一个从日本来的小伙长得很像，但是日本小伙做的是很赚钱很上流的事，具体啥事忘了，好像是拳击。于是他经常冒充日本小伙去他的工作地打拳击赚外水，就这么浑水摸鱼很久，咋摸过去的我也不知道。终于有天被日本小伙发现了，两人都很惊奇有个和自己长得这么像的人，在惊奇恐慌之际，他已经突袭谋杀了日本小伙，从此以日本小伙的名义生活，出入高级场所。而这一切我是怎么知道的呢？也是顺藤摸瓜在运营商服务员那查出来的。于是真相大白了开始抓凶手。</li>
<li>抓凶手，不知是怎么走漏了风声，他知道自己露馅了，于是决定先下手为强，去我家打算大开杀戒。我及时赶回了家，在屋前面的院坝，首先我跟他对质，他承认他偷猪了，但是他拒不投降，于是战斗开始，不知道为什么他不是我的对手，也不知道为什么，打着打着他现原形了。。。原来他是鬼。。。我打的更用力了，能记起的现场是他头发被从头皮撕开，鲜血淋漓，随后头盖骨也掀开，鲜血像沸腾一样在那跳，周围的人突然被迷惑了，看着这鲜血沸腾的头颅，大家都看成了一盘好吃的菜，正打算下嘴，被我一声吆喝，大家才从迷惑中解除，瞬间吓得后退，而那个鲜血沸腾的头颅居然变成了类似韩国僵尸的东西继续跟我对战，和韩国僵尸类似，只要被他抓伤的人马上也会变僵尸。很不幸在我解决他之前，奶奶被他抓伤了，变成僵尸继续来抓我们，我们躲进屋里，但是门是坏的，奶奶一直在门外撞门，眼看门就要被撞开了，大家突然不知道咋的蹦的一下跳到好远的地方，让奶奶追不上，趁奶奶追不上这段时间大家乘飞机安全脱险了。</li>
<li>以为故事终于完了，突然感觉门被风吹开了一条缝，原来自己是在做梦，梦醒了。但是我却动不了，眼睛感觉看到什么东西从门外进来慢慢向我靠近，我不停的挣扎，掐自己肉不行，然后又用力摆头，还用力掐睡在边上的老婆，一顿操作之后，终于我醒了，卧槽，又是鬼压床。好久没碰到过了。我摇醒老婆说我刚才碰到鬼压床了，我掐你才醒了挣脱开的。她说没感到我掐她啊。我再看门有没有开一条缝，也没有。卧槽。。。心里一阵哆嗦，再也睡不着觉了，拿起手机记下刚才发生的一切。天慢慢亮了，凌晨六点。</li>
</ol>
]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>正确使用volatile</title>
    <url>/article/%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8volatile/</url>
    <content><![CDATA[<h3 id="volatile语义">volatile语义</h3>
<pre><code>     1. 内存可见性
        一个线程修改了volatile修饰的变量的值后，新值对另一个线程立即可见
        
     2. 禁止指令重排序优化
        对volatile修饰对变量进行读写操作的前后插入内存屏障以达到禁止volatile修饰的变量和其前后其他变量的指令重排序
        
     3. 使用时的表现：
        对volatile修饰的变量进行读操作时，将线程工作内存里的变量副本置为无效，然后从主内存读取并刷新工作内存的变量副本
        对volatile修饰对变量进行写操作时，将线程工作内存里对变量副本刷新到主内存
        
     4. 注意事项：
        volatile只能保证可见性和对此变量单独操作的原子性，当对volatile修饰的变量涉及到复合操作时不能保证原子性，也就不能保证并发的安全性了
        比如：
        private static volatile int count = 0;
                  count++; //累加操作是一个复合操作，即使volatile修饰，多线程时也不能保证原子性
       
       private static volatile boolean flag = false;
              flag = true; //当作标志位使用时，使用volatile可以保证多线程并发安全性
</code></pre>
<p>参考文章<a href="https://juejin.im/post/5e7771446fb9a07cce7507f2#heading-12" target="_blank" rel="noopener">【编程玄学】一个困扰我122天的技术问题，我好像知道答案了</a>，不使用volatile时由于JIT优化，会出现很多表面看起来莫名其妙的问题，所以一定要正确使用volatile，不要依赖于编译器和JVM的优化操作。</p>
<h3 id="举例说明">举例说明</h3>
<p>环境：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[qiaojian@Mac ~ ]% java -version                                                          [0]</span><br><span class="line">java version "1.8.0_131"</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_131-b11)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode)</span><br></pre></td></tr></table></figure>
<p>如下代码片段，注意两个地方：</p>
<ol>
<li>设置flag为true之前sleep 2毫秒</li>
<li>在while循环里累加计数</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVolatile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NonVolatile nonVolatile = <span class="keyword">new</span> NonVolatile();</span><br><span class="line">        nonVolatile.start();</span><br><span class="line">        <span class="keyword">while</span> (!nonVolatile.flag) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"FLAG:TRUE 主程序退出"</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NonVolatile</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="comment">//private volatile boolean flag = false;</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 程序执行结果还依赖于sleep时间</span></span><br><span class="line">                Thread.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">            System.out.println(<span class="string">"SET FLAG=TRUE"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译运行代码执行结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[qiaojian@Mac ~ ]% java TestVolatile                                                      [0]</span><br><span class="line">SET FLAG=TRUE</span><br><span class="line">FLAG:TRUE 主程序退出 61475</span><br></pre></td></tr></table></figure>
<p>然后我们把sleep时间设置长一点比如10毫秒</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVolatile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NonVolatile nonVolatile = <span class="keyword">new</span> NonVolatile();</span><br><span class="line">        nonVolatile.start();</span><br><span class="line">        <span class="keyword">while</span> (!nonVolatile.flag) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"FLAG:TRUE 主程序退出"</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NonVolatile</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="comment">//private volatile boolean flag = false;</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 程序执行结果还依赖于sleep时间</span></span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">            System.out.println(<span class="string">"SET FLAG=TRUE"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次编译运行看看效果，发现此时主线程死循环了未退出程序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[qiaojian@Mac ~ ]% java TestVolatile                                                      [0]</span><br><span class="line">SET FLAG=TRUE</span><br><span class="line">^C%</span><br></pre></td></tr></table></figure>
<p>再次执行，这次加上禁止JIT优化选项，发现主线程可以正常退出了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[qiaojian@Mac ~ ]% java -Xint TestVolatile                                                [0]</span><br><span class="line">SET FLAG=TRUE</span><br><span class="line">FLAG:TRUE 主程序退出 488111</span><br></pre></td></tr></table></figure>
<p>由此可见，sleep时间的长短对共享变量的可见性也有影响，为什么呢？</p>
<p>因为sleep时间短，while循环短不会触发JIT优化操作。while循环过长超过一定次数时会触发JIT优化操作，将</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!nonVolatile.flag) &#123;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!nonVolatile.flag) &#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    		count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们将flag变量使用volatile修饰，会发现不管设置flag为true之前sleep多久，主线程都可以正常退出。这就是volatile关键字对程序正确性所作出的保证。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVolatile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NonVolatile nonVolatile = <span class="keyword">new</span> NonVolatile();</span><br><span class="line">        nonVolatile.start();</span><br><span class="line">        <span class="keyword">while</span> (!nonVolatile.flag) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"FLAG:TRUE 主程序退出"</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NonVolatile</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//private boolean flag = false;</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 程序执行结果还依赖于sleep时间</span></span><br><span class="line">                Thread.sleep(<span class="number">30</span>*<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">            System.out.println(<span class="string">"SET FLAG=TRUE"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[qiaojian@Mac ~ ]% java TestVolatile                                                      [0]</span><br><span class="line">SET FLAG=TRUE</span><br><span class="line">FLAG:TRUE 主程序退出 1628189977</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>volatile</tag>
      </tags>
  </entry>
  <entry>
    <title>java线上实时debug利器</title>
    <url>/article/java%E7%BA%BF%E4%B8%8A%E5%AE%9E%E6%97%B6debug%E5%88%A9%E5%99%A8/</url>
    <content><![CDATA[<h2 id="btrace">BTrace</h2>
<p>BTrace可用于动态跟踪正在运行的Java程序。BTrace官网：<a href="https://github.com/btraceio/btrace" target="_blank" rel="noopener">https://github.com/btraceio/btrace</a></p>
<h3 id="安装">安装</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#下载安装包</span><br><span class="line">wget https://github.com/btraceio/btrace/releases/download/v1.3.11.3/btrace-bin-1.3.11.3.tgz</span><br><span class="line">#解压</span><br><span class="line">tar -xzvf btrace-bin-1.3.11.3.tgz</span><br><span class="line">#添加PATH和JAVA_HOME环境变量</span><br><span class="line">vim ~/.bashrc</span><br><span class="line">export PATH=$PATH:/root/btrace/bin</span><br><span class="line">export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.222.b10-0.el7_6.x86_64</span><br></pre></td></tr></table></figure>
<h3 id="编写btrace脚本">编写BTrace脚本</h3>
<p>BTrace脚本是纯java代码，主要使用BTrace提供的工具btrace.BTraceUtils和注解btrace.annotations来实现对监控对象的实时打印统计。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import com.sun.btrace.annotations.*;</span><br><span class="line">import static com.sun.btrace.BTraceUtils.*;</span><br><span class="line"></span><br><span class="line">@BTrace</span><br><span class="line">public class V2RTrace &#123;</span><br><span class="line">        @OnMethod(</span><br><span class="line">            clazz=&quot;com.serverbase.controller.V2RForClientController&quot;,</span><br><span class="line">            method=&quot;sendSms&quot;,</span><br><span class="line">            location=@Location(Kind.RETURN)</span><br><span class="line">    )</span><br><span class="line">    public static void traceExecute(String mobile , @Return Object result)&#123;</span><br><span class="line">        println(&quot;call V2RForClientController.&quot;);</span><br><span class="line">        println(strcat(&quot;param mobile is:&quot;,(mobile)));</span><br><span class="line">        println(strcat(&quot;return status is:&quot;,str(get(field(&quot;com.serverbase.common.dto.ServerReturn&quot;, &quot;status&quot;), result))));</span><br><span class="line">        println(strcat(&quot;return msg is:&quot;,str(get(field(&quot;com.serverbase.common.dto.ServerReturn&quot;, &quot;msg&quot;), result))));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行btrace">运行btrace</h3>
<p>btrace运行命令如下所示：</p>
<blockquote>
<p>btrace -cp /root/btrace/build  -p 16111 4634 ./V2RTrace.java</p>
</blockquote>
<p>-cp 指定classpath包含btrace的jar包路径</p>
<p>-p 指定btrace运行的端口</p>
<p>4634 被监控的Java进程号</p>
<p>V2RTrace.java btrace监控脚本java代码文件</p>
<p>监控效果如图所示：</p>
<p><img src="https://qiaojiande-1259482780.cos.ap-chengdu.myqcloud.com/201908/btrace-run.jpg" alt=""></p>
<h2 id="arthas">Arthas</h2>
<p>Arthas 可以说是BTrace的进阶版，提供了操作更方便的命令行界面，不需要再编写脚本，通过Arthas提供的命令即可实现在线debug。使用方式详见官网：<a href="https://github.com/alibaba/arthas" target="_blank" rel="noopener">https://github.com/alibaba/arthas</a></p>
<p>实践中<strong>远程debug</strong>搞了好久，以免踩坑记录一下。</p>
<blockquote>
<p>一键脚本安装arthas</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -L https://alibaba.github.io/arthas/install.sh | sh</span><br></pre></td></tr></table></figure>
<blockquote>
<p>修改as.sh脚本，让执行as.sh脚本时，只attach，不进入交互debug界面</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># target process id to attach</span><br><span class="line"># 此默认配置表示arthas server只允许本机可访问，要允许远程debug，修改为：0.0.0.0</span><br><span class="line">TARGET_IP=&quot;127.0.0.1&quot;</span><br><span class="line"></span><br><span class="line"># telnet port</span><br><span class="line"># 此默认配置表示arthas server telnet端口为3685</span><br><span class="line">TELNET_PORT=&quot;3658&quot;</span><br><span class="line"></span><br><span class="line"># http port</span><br><span class="line">#此默认配置表示arthas server http端口为8563</span><br><span class="line">HTTP_PORT=&quot;8563&quot;</span><br><span class="line"># attach only, do not telnet connect</span><br><span class="line">#此配置默认为false，改为true表示执行as.sh脚本时，只attach java process，不进入交互debug界面</span><br><span class="line">ATTACH_ONLY=true</span><br></pre></td></tr></table></figure>
<blockquote>
<p>启动arthas server，attach要debug 的java进程</p>
</blockquote>
<p><a href="http://as.sh" target="_blank" rel="noopener">as.sh</a> PID</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@qiaojian ~]# as.sh 32431</span><br><span class="line">Arthas script version: 3.1.1</span><br><span class="line">[INFO] JAVA_HOME: /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.222.b10-0.el7_6.i386</span><br><span class="line">Arthas home: /root/.arthas/lib/3.1.1/arthas</span><br><span class="line">Calculating attach execution time...</span><br><span class="line">Attaching to 32431 using version /root/.arthas/lib/3.1.1/arthas...</span><br><span class="line"></span><br><span class="line">real    0m1.109s</span><br><span class="line">user    0m0.200s</span><br><span class="line">sys     0m0.025s</span><br><span class="line">Attach success.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>远程telnet连接</p>
</blockquote>
<p><img src="https://qiaojiande-1259482780.cos.ap-chengdu.myqcloud.com/201908/arthas-telnet-remote.jpg" alt=""></p>
<blockquote>
<p>远程http连接</p>
</blockquote>
<p><img src="https://qiaojiande-1259482780.cos.ap-chengdu.myqcloud.com/201908/arthas-http-remote.jpg" alt=""></p>
]]></content>
      <tags>
        <tag>btrace</tag>
      </tags>
  </entry>
  <entry>
    <title>v2ray-kill-GFW</title>
    <url>/article/v2ray-kill-GFW/</url>
    <content><![CDATA[<h3 id="v2ray-服务端-搭在vps服务器上通过docker-运行">v2ray 服务端 搭在vps服务器上，通过docker 运行</h3>
<p>配置文件：/etc/v2ray/config.json，使用配置文件生成器 <a href="https://intmainreturn0.com/v2ray-config-gen/#" target="_blank" rel="noopener">https://intmainreturn0.com/v2ray-config-gen/#</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;log&quot;: &#123;</span><br><span class="line">        &quot;access&quot;: &quot;/var/log/v2ray/access.log&quot;,</span><br><span class="line">        &quot;error&quot;: &quot;/var/log/v2ray/error.log&quot;,</span><br><span class="line">        &quot;loglevel&quot;: &quot;warning&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;inbound&quot;: &#123;</span><br><span class="line">        &quot;port&quot;: 18888,</span><br><span class="line">        &quot;protocol&quot;: &quot;vmess&quot;,</span><br><span class="line">        &quot;settings&quot;: &#123;</span><br><span class="line">            &quot;clients&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;id&quot;: &quot;5baf256b-ee48-7baf-3a88-9e6a452e16f4&quot;,</span><br><span class="line">                    &quot;level&quot;: 1,</span><br><span class="line">                    &quot;alterId&quot;: 64</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;outbound&quot;: &#123;</span><br><span class="line">        &quot;protocol&quot;: &quot;freedom&quot;,</span><br><span class="line">        &quot;settings&quot;: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;inboundDetour&quot;: [],</span><br><span class="line">    &quot;outboundDetour&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;protocol&quot;: &quot;blackhole&quot;,</span><br><span class="line">            &quot;settings&quot;: &#123;&#125;,</span><br><span class="line">            &quot;tag&quot;: &quot;blocked&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;routing&quot;: &#123;</span><br><span class="line">        &quot;strategy&quot;: &quot;rules&quot;,</span><br><span class="line">        &quot;settings&quot;: &#123;</span><br><span class="line">            &quot;rules&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;type&quot;: &quot;field&quot;,</span><br><span class="line">                    &quot;ip&quot;: [</span><br><span class="line">                        &quot;0.0.0.0/8&quot;,</span><br><span class="line">                        &quot;10.0.0.0/8&quot;,</span><br><span class="line">                        &quot;100.64.0.0/10&quot;,</span><br><span class="line">                        &quot;127.0.0.0/8&quot;,</span><br><span class="line">                        &quot;169.254.0.0/16&quot;,</span><br><span class="line">                        &quot;172.16.0.0/12&quot;,</span><br><span class="line">                        &quot;192.0.0.0/24&quot;,</span><br><span class="line">                        &quot;192.0.2.0/24&quot;,</span><br><span class="line">                        &quot;192.168.0.0/16&quot;,</span><br><span class="line">                        &quot;198.18.0.0/15&quot;,</span><br><span class="line">                        &quot;198.51.100.0/24&quot;,</span><br><span class="line">                        &quot;203.0.113.0/24&quot;,</span><br><span class="line">                        &quot;::1/128&quot;,</span><br><span class="line">                        &quot;fc00::/7&quot;,</span><br><span class="line">                        &quot;fe80::/10&quot;</span><br><span class="line">                    ],</span><br><span class="line">                    &quot;outboundTag&quot;: &quot;blocked&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>docker 拉 v2ray镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull v2ray/official</span><br></pre></td></tr></table></figure>
<p>docker run v2ray 容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d --name v2ray -v /etc/v2ray:/etc/v2ray -v /var/log/v2ray:/var/log/v2ray -p 18888:18888 --restart=always v2ray/official  v2ray -config=/etc/v2ray/config.json</span><br></pre></td></tr></table></figure>
<h3 id="v2ray-客户端v2rayu-mac客户端">v2ray 客户端：v2rayU mac客户端</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">v2ray 配置默认监听sock 端口 1080，配置v2ray服务器inbound的地址、端口、id</span><br><span class="line">所用浏览器代理软件：SwitchyOmega，配置代理协议地址端口：sock | 127.0.0.1 | 1080</span><br><span class="line">v2ray 客户端会将通过 sock协议 + 1080端口收到的数据用vmess协议封装发送给v2ray服务器</span><br></pre></td></tr></table></figure>
<h3 id="v2ray-服务器非docker一键搭建">v2ray 服务器非docker一键搭建：</h3>
<p>bash &lt;(curl -L -s <a href="https://install.direct/go.sh" target="_blank" rel="noopener">https://install.direct/go.sh</a>)</p>
<p>vi /etc/v2ray/config.json</p>
<p>service v2ray restart</p>
<h3 id="kill-gfw-原理">Kill GFW 原理</h3>
<p>本地使用正向代理v2ray客户端，v2ray客户端监听在1080端口，配置浏览器代理插件SwitchyOmega将所有http流量用sock5协议封装转到本地localhost:1080，v2ray客户端将收到的sock5数据用vmess协议封装发送给v2ray服务器，服务器解析出里面的http流量，发起http请求，拿到响应后，继续用vmess封装，发回v2ray客户端，v2ray客户端解析出sock5数据从1080端口发送回浏览器代理插件SwitchyOmega，SwitchyOmega再解析出http响应数据，返回给浏览器</p>
]]></content>
      <tags>
        <tag>v2ray</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-模板方法</title>
    <url>/article/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p><strong>模板方法模式</strong>是一种行为设计模式， 它在超类中定义了一个算法的框架， 允许子类在不修改结构的情况下重写算法的特定步骤。</p>
<p>有两种类型的步骤：</p>
<ul>
<li><em>抽象步骤</em>必须由各个子类来实现</li>
<li><em>可选步骤</em>已有一些默认实现， 但仍可在需要时进行重写</li>
</ul>
<p>继续优化策略模式中的支付策略，由于不同的支付的总的处理过程都是一样的：先构造参数，再对参数进行签名，发起支付请求，最后解析返回结果。因此可以应用模板方法。</p>
<p>首先定义一个抽象类如下：Pay</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Pay</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模板（算法框架，超类定义好，子类不可修改）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">exec</span><span class="params">(Map&lt;String, Object&gt; param)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// step1: 根据输入参数组合支付请求需要的参数，不同的支付传入的参数不同，组合出来的参数也不同</span></span><br><span class="line">        Map&lt;String, Object&gt; urlParam = genUrlParam(param);</span><br><span class="line">        <span class="comment">// step2: 对url参数进行签名，签名方法有很多：比如RSA，MD5，AES...</span></span><br><span class="line">        String sign = genSign(urlParam);</span><br><span class="line">        urlParam.put ( <span class="string">"sign"</span>, sign );</span><br><span class="line">        <span class="comment">// step3: 发起支付请求，支付发起方式GET，POST</span></span><br><span class="line">        String result = callPayUrl(urlParam);</span><br><span class="line">        <span class="comment">// step4: 解析请求结果并返回，返回结果有很多类型：XML，JSON，自定义结构...</span></span><br><span class="line">        <span class="keyword">return</span> parseResult(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Map&lt;String, Object&gt; <span class="title">genUrlParam</span><span class="params">(Map&lt;String, Object&gt; param)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">genSign</span><span class="params">(Map&lt;String, Object&gt; param)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">callPayUrl</span><span class="params">(Map&lt;String, Object&gt; param)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">parseResult</span><span class="params">(String result)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//除此以外，模板超类中还可以定义默认实现，子类也可以根据情况覆写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在具体的继承类中实现特定的步骤也即实现抽象类中的抽象方法。</p>
<p>定义具体的实现类之微信支付：WeChatPay</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeChatPay</span> <span class="keyword">extends</span> <span class="title">Pay</span> <span class="keyword">implements</span> <span class="title">PayStrategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doPay</span><span class="params">(String type, Map&lt;String, Object&gt; param)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exec ( param );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Map&lt;String, Object&gt; <span class="title">genUrlParam</span><span class="params">(Map&lt;String, Object&gt; param)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">genSign</span><span class="params">(Map&lt;String, Object&gt; param)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">callPayUrl</span><span class="params">(Map&lt;String, Object&gt; param)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">parseResult</span><span class="params">(String result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义具体的实现类之支付宝支付：ALiPay</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ALiPay</span> <span class="keyword">extends</span> <span class="title">Pay</span> <span class="keyword">implements</span> <span class="title">PayStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doPay</span><span class="params">(String type, Map&lt;String, Object&gt; param)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exec ( param );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Map&lt;String, Object&gt; <span class="title">genUrlParam</span><span class="params">(Map&lt;String, Object&gt; param)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">genSign</span><span class="params">(Map&lt;String, Object&gt; param)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">callPayUrl</span><span class="params">(Map&lt;String, Object&gt; param)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">parseResult</span><span class="params">(String result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义具体的实现类之银联支付：UnionPay</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionPay</span> <span class="keyword">extends</span> <span class="title">Pay</span> <span class="keyword">implements</span> <span class="title">PayStrategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doPay</span><span class="params">(String type, Map&lt;String, Object&gt; param)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exec ( param );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Map&lt;String, Object&gt; <span class="title">genUrlParam</span><span class="params">(Map&lt;String, Object&gt; param)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">genSign</span><span class="params">(Map&lt;String, Object&gt; param)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">callPayUrl</span><span class="params">(Map&lt;String, Object&gt; param)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">parseResult</span><span class="params">(String result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类的具体实现就没写了，模板方法的应用大概如此。</p>
<p>另外：抽象类是可以不包含抽象方法的，此时抽象类仍然不能被实例化。可以用在所有方法都是静态方法的工具类上，此时把这种工具类定义为抽象类，可以防止它被实例化。例如SpringBoot框架中的org.springframework.util包下的很多工具类就是这种用法。</p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-归并排序</title>
    <url>/article/%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>归并排序利用分而治之的办法将问题大化小，平均、最坏、最好时间复杂度都是O(nlogn)，采用递归法：</p>
<ol>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li>
<li>重复步骤3直到某一指针到达序列尾</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾</li>
</ol>
<p>递归法的Java实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX = <span class="number">100000</span>;<span class="comment">//100000个数进行排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] ints = <span class="keyword">new</span> <span class="keyword">int</span>[MAX];</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> index = <span class="number">1</span> ; index &lt;= MAX ; index++) &#123;</span><br><span class="line">            ints[index - <span class="number">1</span>] = r.nextInt(<span class="number">10000000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis ();</span><br><span class="line">        <span class="comment">//ints = new int[]&#123;9,8,7,6,5,4,3,2,1&#125;;</span></span><br><span class="line">        sort( ints );</span><br><span class="line">        System.out.println(Arrays.toString( ints ));</span><br><span class="line">        System.out.println ( (System.currentTimeMillis () - start) );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> []arr)</span></span>&#123;</span><br><span class="line">        sort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以待排序数组 arr &#123;9,8,7,6,5,4,3,2,1&#125;举例：程序的运行流程如下: (如下数字表示数组下标)</span></span><br><span class="line"><span class="comment">     *  1.  sort 0, 8</span></span><br><span class="line"><span class="comment">     *  2.  sort 0, 4 (left, mid)</span></span><br><span class="line"><span class="comment">     *  3.  sort 0, 2 (left, mid)</span></span><br><span class="line"><span class="comment">     *  4.  sort 0, 1 (left, mid)</span></span><br><span class="line"><span class="comment">     *  5.  sort 0, 0 (left, mid) (自然有序，直接返回)</span></span><br><span class="line"><span class="comment">     *  6.  sort 1, 1 (mid+1, right) (自然有序，直接返回)</span></span><br><span class="line"><span class="comment">     *  7. merge [0,0,1] (合并[0],[1]成[0,1])</span></span><br><span class="line"><span class="comment">     *  9. 递归返回到 3. sort 0, 2 的下一步: sort 2, 2 (mid+1, right) (自然有序，直接返回)</span></span><br><span class="line"><span class="comment">     * 10. merge [0,1,2] (合并[0,1],[2]成[0,2])</span></span><br><span class="line"><span class="comment">     * 11. 递归返回到 2. sort 0, 4 的下一步: sort3, 4 (mid+1, right)</span></span><br><span class="line"><span class="comment">     * 12. sort 3, 3 (left, mid) (自然有序，直接返回)</span></span><br><span class="line"><span class="comment">     * 13. sort 4, 4 (mid+1, right) (自然有序，直接返回)</span></span><br><span class="line"><span class="comment">     * 15. merge [3,3,4] (合并[3],[4]成[3,4])</span></span><br><span class="line"><span class="comment">     * 16. merge [0,2,4] (合并[0,2],[3,4]成[0,4]) （至此，左边排序sort(arr,left,mid)完成）</span></span><br><span class="line"><span class="comment">     * 17. sort 5, 8 (mid+1, right) (继续进行右边排序sort(arr,mid+1,right))</span></span><br><span class="line"><span class="comment">     * 18. sort 5, 6 (left, mid)</span></span><br><span class="line"><span class="comment">     * 19. sort 5, 5 (left, mid) (自然有序，直接返回)</span></span><br><span class="line"><span class="comment">     * 20. sort 6, 6 (mid+1, right) (自然有序，直接返回)</span></span><br><span class="line"><span class="comment">     * 21. merge [5,5,6] (合并[5],[6]成[5,6])</span></span><br><span class="line"><span class="comment">     * 22. 递归返回到 17. sort 5, 8 的下一步: sort 7, 8 (mid+1, right)</span></span><br><span class="line"><span class="comment">     * 23. sort 7, 7 (left, mid) (自然有序，直接返回)</span></span><br><span class="line"><span class="comment">     * 24. sort 8, 8 (mid+1, right) (自然有序，直接返回)</span></span><br><span class="line"><span class="comment">     * 25. merge [7,7,8] (合并[7],[8]成[7,8])</span></span><br><span class="line"><span class="comment">     * 26. merge [5,6,8] (合并[5,6],[7,8]成[5,8]) (至此，右边排序sort(arr,mid+1,right)完成)</span></span><br><span class="line"><span class="comment">     * 27. merge [0,4,8] (合并[0,4],[5,8]成[0,8]) (至此，左右两边合并排序完成)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">            sort(arr,left,mid);<span class="comment">//左边归并排序，使得左子序列有序</span></span><br><span class="line">            sort(arr,mid+<span class="number">1</span>,right);<span class="comment">//右边归并排序，使得右子序列有序</span></span><br><span class="line">            merge(arr,left,mid,right);<span class="comment">//将两个有序子数组合并操作</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = left;<span class="comment">//左序列指针</span></span><br><span class="line">        <span class="keyword">int</span> j = mid+<span class="number">1</span>;<span class="comment">//右序列指针</span></span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;<span class="comment">//临时数组指针</span></span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">while</span> (i&lt;=mid &amp;&amp; j&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&lt;=arr[j])&#123;</span><br><span class="line">                temp[t++] = arr[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                temp[t++] = arr[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid)&#123;<span class="comment">//将左边剩余元素填充进temp中</span></span><br><span class="line">            temp[t++] = arr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=right)&#123;<span class="comment">//将右序列剩余元素填充进temp中</span></span><br><span class="line">            temp[t++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//将temp中的元素全部拷贝到原数组中</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            arr[left++] = temp[t++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由以上递归法的实现可知：大化小排序是可以并发进行的，利用多线程并发排序如下：ForkJoinTask任务排序：</p>
<p>ForkJoinSortTask.java:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public class ForkJoinSortTask extends RecursiveTask&lt;int[]&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] ints;</span><br><span class="line"></span><br><span class="line">    ForkJoinSortTask(<span class="keyword">int</span>[] ints) &#123;</span><br><span class="line">        <span class="keyword">this</span>.ints = ints;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 归并排序的特征：利用分治法，可以利用多线程同时进行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span>[] compute() &#123;</span><br><span class="line">        <span class="keyword">int</span> len = ints.length;</span><br><span class="line">        <span class="keyword">if</span> (len &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = len / <span class="number">2</span>;</span><br><span class="line">            ForkJoinSortTask leftTask = <span class="keyword">new</span> ForkJoinSortTask ( Arrays.copyOf ( ints, mid) );</span><br><span class="line">            leftTask.fork ();</span><br><span class="line">            ForkJoinSortTask rightTask = <span class="keyword">new</span> ForkJoinSortTask ( Arrays.copyOfRange ( ints, mid, len) );</span><br><span class="line">            rightTask.fork ();</span><br><span class="line">            <span class="keyword">return</span> merge(leftTask.join (), rightTask.join ());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (len != <span class="number">1</span> &amp;&amp; ints[<span class="number">0</span>] &gt;= ints[<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = ints[<span class="number">1</span>];</span><br><span class="line">                ints[<span class="number">1</span>] = ints[<span class="number">0</span>];</span><br><span class="line">                ints[<span class="number">0</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ints;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将两个有序的数组合并成一个有序数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] merge(<span class="keyword">int</span>[] leftSorted, <span class="keyword">int</span>[] rightSorted) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] merged = <span class="keyword">new</span> <span class="keyword">int</span>[leftSorted.length + rightSorted.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; leftSorted.length + rightSorted.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left == leftSorted.length) &#123;</span><br><span class="line">                merged[i] = rightSorted[right];</span><br><span class="line">                right++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right == rightSorted.length) &#123;</span><br><span class="line">                merged[i] = leftSorted[left];</span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (leftSorted[left] &lt; rightSorted[right]) &#123;</span><br><span class="line">                merged[i] = leftSorted[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                merged[i] = rightSorted[right];</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> merged;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ForkJoinSort.java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX = <span class="number">100000</span>;<span class="comment">//100000个数进行排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] ints = <span class="keyword">new</span> <span class="keyword">int</span>[MAX];</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> index = <span class="number">1</span> ; index &lt;= MAX ; index++) &#123;</span><br><span class="line">            ints[index - <span class="number">1</span>] = r.nextInt(<span class="number">10000000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis ();</span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool (  );</span><br><span class="line">        ForkJoinSortTask forkJoinSortTask = <span class="keyword">new</span> ForkJoinSortTask ( ints );</span><br><span class="line">        <span class="comment">//ForkJoinSortTask forkJoinSortTask = new ForkJoinSortTask ( new int[]&#123;9,8,7,6,5,4,3,2,1&#125;);</span></span><br><span class="line">        ForkJoinTask&lt;<span class="keyword">int</span>[]&gt; forkJoinTask = forkJoinPool.submit ( forkJoinSortTask );</span><br><span class="line">        <span class="keyword">int</span>[] result = forkJoinTask.get ();</span><br><span class="line">        System.out.println( Arrays.toString(result));</span><br><span class="line">        System.out.println ( (System.currentTimeMillis () - start) );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对比以上两种排序实现，未使用多线程，排序100000个随机数大概需要5秒，利用多线程只需要200毫秒以内</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-工厂模式</title>
    <url>/article/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>工厂模式包括：工厂方法模式和抽象工厂模式，可以说抽象工厂模式是在工厂方法模式基础上演变而来的。</p>
<hr>
<p>工厂方法的作用就是：</p>
<p>原来我们要new一个产品A，则直接new ProductA(); 又来一个新需求要new一个产品B，则直接new ProductB();  依此类推…</p>
<p>工厂的作用就是提供一个工厂类，由工厂类负责new ProductA()和new ProductB()，而我们只需要传入类型参数new一个工厂类就可以了，工厂类会根据类型来new相应的产品并返回。</p>
<p>注意在工厂方法中，产品A和产品B一般是没有关联的。</p>
<p>用类表示如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Product接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ProductA</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductA</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ProductB</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductB</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">getProduct</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="string">"A"</span>.equalsIgnoreCase ( type )) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> ProductA ();</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"B"</span>.equalsIgnoreCase ( type ) ) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> ProductB ();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>那什么是抽象工厂呢？抽象工厂要解决的问题是：要生成ProductA需要经过三个流程：选购原材料，加工原材料，组装，要生成ProductB也需要经过三个流程：选购原材料，加工原材料，组装，但是各自的流程处理方式都不一样，怎么办呢？</p>
<p>原来的做法是：直接在new Product里添加各自的流程，ProducA和ProductB的流程各自独立，客户端要使用时都是和具体的产品A或B打交道，紧耦合。</p>
<p>抽象工厂就是将生成ProductA的流程封装到一个工厂类ProductA中，将生成ProductB的流程也封装到一个工厂类ProductB中，然后将生成产品的流程抽象到共同的接口Product中，让ProductA和ProductB实现此接口，这么做的前提是工厂生产不同产品的流程是一样的。</p>
<p>现在需要生成产品的客户端只需要提供接口Product属性，具体需要生成ProductA则将此接口属性实例化为ProducA工厂，由具体工厂来执行具体的产品流程。</p>
<p>如果需要新增生成一个产品ProductC，只需要新增具体工厂类ProductC就可以了。</p>
<p>用类表示如下：</p>
<p>接着上面工厂方法的产品类，增加三个流程处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原材料类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Material</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//组装成的模块类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Model</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象工厂接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AbstractProductFactory</span> </span>&#123;</span><br><span class="line">   <span class="function">Material <span class="title">buyMaterial</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function">Model <span class="title">process</span><span class="params">(Material material)</span></span>;</span><br><span class="line">   <span class="function">Product <span class="title">assemble</span><span class="params">(Model model)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生产产品A的工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductAFactory</span> <span class="keyword">implements</span> <span class="title">AbstractProductFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Material <span class="title">buyMaterial</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Model <span class="title">process</span><span class="params">(Material material)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">assemble</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生产产品B的工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductBFactory</span> <span class="keyword">implements</span>  <span class="title">AbstractProductFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Material <span class="title">buyMaterial</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Model <span class="title">process</span><span class="params">(Material material)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">assemble</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象工厂的使用类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsageApp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AbstractProductFactory factory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UsageApp</span><span class="params">(AbstractProductFactory factory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.factory = factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//UsageApp初始化时传入具体的工厂类，此方法即生产出相应的产品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">genProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.factory.assemble (</span><br><span class="line">                <span class="keyword">this</span>.factory.process (</span><br><span class="line">                        <span class="keyword">this</span>.factory.buyMaterial ()</span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>区别：工厂方法是对产品的扩展，抽象工厂是对生成产品的工厂的扩展</p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-策略模式</title>
    <url>/article/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><strong>策略模式</strong>是对算法的封装，它把算法的责任和算法本身分割开，委派给不同的对象管理。 <strong>策略模式</strong>通常把一个系列的算法封装到一系列的<strong>策略</strong>类里面，作为一个抽象<strong>策略</strong>类的子类。 用一句话来说，就是“准备一组算法，并将每一个算法封装起来，使得它们可以互换”。</p>
<p>策略模式包含如下角色：</p>
<ul>
<li>Context: 环境类</li>
<li>Strategy: 抽象策略类</li>
<li>ConcreteStrategy: 具体策略类</li>
</ul>
<p>现在来根据角色实现一个支付策略：</p>
<p>首先定义一个支付接口：PayStrategy</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PayStrategy</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">doPay</span><span class="params">(String type, Map&lt;String, Object&gt; param)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义具体的实现类之微信支付：WeChatPay</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeChatPay</span> <span class="keyword">implements</span> <span class="title">PayStrategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doPay</span><span class="params">(String type, Map&lt;String, Object&gt; param)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"微信支付"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义具体的实现类之支付宝支付：ALiPay</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ALiPay</span> <span class="keyword">implements</span> <span class="title">PayStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doPay</span><span class="params">(String type, Map&lt;String, Object&gt; param)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"支付宝支付"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义具体的实现类之银联支付：UnionPay</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionPay</span> <span class="keyword">implements</span> <span class="title">PayStrategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doPay</span><span class="params">(String type, Map&lt;String, Object&gt; param)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"银联支付"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义一个上下文类，提供不同算法的组合和选择：PayContext</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PayContext</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;PayType, PayStrategy&gt; payStrategyMap = <span class="keyword">new</span> HashMap&lt;&gt; ( );</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    WeChatPay weChatPay;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ALiPay aLiPay;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UnionPay unionPay;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initStrategyMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.payStrategyMap.put ( PayType.WECHATPAY, weChatPay);</span><br><span class="line">        <span class="keyword">this</span>.payStrategyMap.put ( PayType.ALIPAY, aLiPay);</span><br><span class="line">        <span class="keyword">this</span>.payStrategyMap.put ( PayType.UNIONPAY, unionPay);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doCmd</span><span class="params">(String type, Map&lt;String, Object&gt; param)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.payStrategyMap.get ( PayType.getPayType ( type ) ).doPay ( type, param );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中PayType是类型枚举：PayType</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> PayType &#123;</span><br><span class="line">    WECHATPAY(<span class="string">"WECHAT"</span>, <span class="string">"微信支付"</span>),</span><br><span class="line">    ALIPAY(<span class="string">"ALI"</span>, <span class="string">"支付宝支付"</span>),</span><br><span class="line">    UNIONPAY(<span class="string">"UNION"</span>, <span class="string">"银联支付"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    PayType(String type, String desc) &#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PayType <span class="title">getPayType</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (PayType payType: PayType.values ()</span><br><span class="line">             ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (payType.type.equalsIgnoreCase ( type )) &#123;</span><br><span class="line">                <span class="keyword">return</span> payType;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后定义一个controller类来使用我们的支付策略：PayUsage</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PayUsage</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PayContext payContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/pay"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">usePay</span><span class="params">(@RequestParam String type)</span> </span>&#123;</span><br><span class="line">    			 <span class="comment">//测试参数null</span></span><br><span class="line">           <span class="keyword">return</span> payContext.doCmd ( type, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传不同的类型参数调用接口，即使用不同的策略：</p>
<p>curl localhost/pay?type=wechat 返回微信支付</p>
<p>curl localhost/pay?type=ali 返回支付宝支付</p>
<p>curl localhost/pay?type=union 返回银联支付</p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Git手册</title>
    <url>/article/Git%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<h2 id="git基础">Git基础</h2>
<ol>
<li>
<p>什么是版本控制系统（VCS）？</p>
<p>记录文件的变化状态，以便查阅特定节点的文件和对特定节点文件进行修改。</p>
</li>
<li>
<p>集中化的版本控制系统</p>
<p>例如SVN，Perforce等，以C/S的方式进行工作，服务器部署在远端，记录了所有的版本历史和状态，客户端可以从服务器拉取某个特定节点的快照，并作修改和提交。最大的特点是：客户端只拉取到特定节点的快照，不包含整个项目的版本历史和状态。</p>
</li>
<li>
<p>分布式的版本控制系统</p>
<p>例如Git，Mercurial等，同样以C/S的方式工作，但是客户端拉取到的不是对某个节点的快照，而是对整个项目的完整的克隆，包含了整个项目的版本历史和状态。最大的特点：方便灵活，由于每个客户端拉取到的都是完整的代码备份，因此可以多人分小组进行协作，指定不同的工作流。</p>
</li>
<li>
<p>Git的工作原理</p>
<p>Git只关心文件数据的整体是否发生变化，不保存文件的差异。Git 更像是把变化的文件作快照后，记录在一个微型的文件系统中。每次提交更新时，它会纵览一遍所有文件的指纹信息（SHA）并对文件作一快照，然后保存一个指向这次快照的索引。为提高性能，若文件没有变化，Git 不会再次保存，而只对上次保存的快照作一链接。</p>
<p>Git基于分支的管理方式，近乎所有操作都是在本地进行，只有提交合并拉取等少量操作需要和远端服务器进行交互。</p>
<p>Git项目中文件的三种基本状态：Git工作区状态：对文件进行修改，还未保存；Git暂存区：将文件的修改保存在一个中间态（git add）；Git本地仓库区：将修改永久保存到Git仓库中来（git commit）。</p>
</li>
</ol>
<h2 id="git安装">Git安装</h2>
<ol>
<li>源码编译安装</li>
<li>安装包安装</li>
</ol>
<h2 id="git配置">Git配置</h2>
<p>每个Git项目文件夹下都有一个.git目录，它记录了Git项目的文件状态。</p>
<p>使用Git前，需要对Git进行配置，命令git config专门用来配置或读取相应的工作环境变量。</p>
<p>Git会依次读取三个地方的环境变量文件：</p>
<ol>
<li>/etc/gitconfig： 系统级配置，对所有用户生效，通过git config --system读取和配置</li>
<li>~/.gitconfig：用户级配置，只对该用户生效，通过git config --global读取和配置</li>
<li>.git/config：项目级配置，只对当前Git项目生效，直接vim ./git/config读取和修改配置</li>
</ol>
<p>每一个级别的配置都会覆盖上层的相同配置。</p>
<h2 id="git-help">Git help</h2>
<p>git help cmd （eg：git help config）</p>
<p>git cmd --help （eg：git  config  --help）</p>
<p>man git</p>
<h2 id="git项目获取">Git项目获取</h2>
<ol>
<li>
<p>在本地工作目录下新建git仓库</p>
<p>git init</p>
</li>
<li>
<p>从远端现有仓库克隆</p>
<p>git clone <a href="http://url/test.git" target="_blank" rel="noopener">http://url/test.git</a></p>
<p>git clone git://url/test.git</p>
</li>
</ol>
<h2 id="忽略部分文件">忽略部分文件</h2>
<p>编写.gitignore文件，并加入Git仓库</p>
<h2 id="git-命令自动补全">git 命令自动补全</h2>
<p>环境CentOS：</p>
<ol>
<li>
<p>将git源码目录下文件contrib/completion/git-completion.bash 拷贝到本机 /etc/bash_completion.d/</p>
</li>
<li>
<p>编辑~/.bashrc，加入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if [ -f /etc/bash_completion.d/git-completion.bash ]; then</span><br><span class="line">        . /etc/bash_completion.d/git-completion.bash</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>重新source ~/.bashrc</p>
</li>
</ol>
<h2 id="常用命令">常用命令</h2>
<ol>
<li>
<p>git add，添加修改到暂存区，再git commit -m “comment” 提交到本地仓库。git add -i 进入交互式暂存模式。</p>
</li>
<li>
<p>git commit -a -m “comment” 可以跳过git add，直接提交修改到本地仓库，新增的文件还是untracked状态仍然需要先git add。</p>
</li>
<li>
<p>文件重命名：git mv old new</p>
</li>
<li>
<p>查看提交历史：git log</p>
</li>
<li>
<p><strong>修改最近一次提交：git commit --amend（比如：先git commit，发现还有未提交文件，git add 忘提交文件，再次执行git commit --amend，会覆盖上次的commit，git log中只会记录最近这次的commit。注意不能修改已经push的commit，会导致再次push冲突）</strong></p>
</li>
<li>
<p>取消保存到暂存区的文件：git reset HEAD file，此操作会将git add的文件还原回修改待添加的状态</p>
</li>
<li>
<p>放弃对文件的修改：git checkout – file，此操作会将已经修改待添加的文件的修改删除，慎用</p>
</li>
<li>
<p>放弃对已经保存到暂存区的文件的修改：git reset --hard commitNo （commitNo指reset到哪个提交点，默认是HEAD所在提交点）</p>
<p>git reset 回滚：</p>
<blockquote>
<p>三种模式：默认mixed模式</p>
<p>git reset [–soft | --mixed | --hard] commitNo</p>
<p>–soft：回滚到指定commitNo，此commitNo之后的提交修改（git commit）回滚到暂存区状态（git add）</p>
<p>–mixed：回滚到指定commitNo，此commitNo之后的提交修改（git commit）回滚到已修改状态（未执行git  add）</p>
<p>–hard：回滚到指定commitNo，此commitNo之后的提交修改（git commit）直接丢弃</p>
</blockquote>
</li>
<li>
<p>git fetch：拉取远程仓库的分支信息和tag信息</p>
</li>
<li>
<p>打标签：分为：轻量级标签（只是个引用，指向某个提交点），含附注的标签（独立的一个标签对象）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看所有标签：git tag</span><br><span class="line">新建轻量级标签 git tag v1.0</span><br><span class="line">新建含附注标签 git tag -a v1.0 -m “coment”</span><br><span class="line">针对某个commit添加标签：git tag -a v1.2 ef35ae2 -m “comment”</span><br><span class="line">将标签信息push到远端仓库：git push origin --tags</span><br><span class="line">切换到某个tag：git checkout v1.0</span><br><span class="line">拉取某个tag：git pull origin :remotes/origin/v1.0</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>git checkout commitNo / git checkout tagName，会导致HEAD执行具体的某次commit或某个tag，此时HEAD处于游离状态（detached），此时基于HEAD的修改会提交到一个新开的匿名分支，一旦切换到其他分支，此detached分支即不可见。解决办法：</p>
<blockquote>
<ol>
<li>git reflog 可以查看之前到所有提交记录</li>
<li>找到之前基于HEAD detached分支的最新提交commitNo</li>
<li>git checkout commitNo，切换到之前基于HEAD detached分支的最新提交commitNo</li>
<li>基于此commit新建一个分支：git checkout -b newDetached</li>
<li>切换回正常分支如master：git checkout master</li>
<li>执行分支合并即可找回之前基于HEAD detached分支的修改：git merge newDetached</li>
</ol>
</blockquote>
</li>
<li>
<p>分支基本操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 基于当前commit创建新分支：git checkout -b branchxx</span><br><span class="line">2. 切换到分支master：git checkout master</span><br><span class="line">3. 在新分支上第一次push同步reference：git push --set-upstream origin branchxx</span><br><span class="line">4. 在分支master下合并branchxx分支：git merge branchxx</span><br><span class="line">5. 删除分支：git branch -d branchxx</span><br><span class="line">6. 同步远程服务器上的数据到本地：git fetch origin</span><br><span class="line"></span><br><span class="line">7. 添加多个远程服务器分支：git remote add githubCalendar git@github.com:qiaojianqj/gitCalendar.git</span><br><span class="line">8. 做新的修改并提交：git cm -a -m &quot;remote add gitCalendar&quot;</span><br><span class="line">9. 推送本地master分支到远程gitCalendar服务器上对应master分支，</span><br><span class="line">语法：git push [远程名] [本地分支]:[远程分支]</span><br><span class="line">默认推送当前所在分支：</span><br><span class="line">git push githubCalendar （git push githubCalendar master:master）</span><br><span class="line">10. 查看本地仓库.git/config文件，有两个remote：origin、githubCalendar，每次推送的时候可以指定remote服务器选择推送到哪个远程服务器，默认推送到origin：</span><br><span class="line">git push (git push origin)</span><br><span class="line">git push githubCalendar</span><br><span class="line">11. 删除远程分支githubCalendar-dev：push的时候如果省略 [本地分支]，那就等于是在说“在这里提取空白然后把它变成[远程分支]，也就删除了远程分支：</span><br><span class="line">11.1 新建远程分支dev：git push githubCalendar master:dev</span><br><span class="line">11.2 删除远程分支dev：git push githubCalendar :dev</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>分支的变基-rebase</p>
<blockquote>
<ol>
<li>变基的应用</li>
</ol>
<p>一般我们使用变基的目的，是想要得到一个能在远程分支上干净应用的补丁 — 比如某些项目你不是维护者，但想帮点忙的话，最好用变基：先在自己的一个本地分支里进行开发，当准备向主项目提交补丁的时候，根据最新的 <code>origin/master</code> 进行一次变基操作然后再提交，这样维护者就不需要做任何整合工作（译注：实际上是把解决分支补丁同最新主干代码之间冲突的责任，化转为由提交补丁的人来解决。），只需根据你提供的仓库地址作一次快进合并，或者直接采纳你提交的补丁。</p>
<ol start="2">
<li>变基不适用的地方</li>
</ol>
<p>如果把变基当成一种在推送之前清理提交历史的手段，而且仅仅变基那些尚未公开的提交对象，就没问题。如果变基那些已经公开的提交对象，并且已经有人基于这些提交对象开展了后续开发工作的话，就不适用，会使得提交历史重复不清</p>
<ol start="3">
<li>变基rebase和合并merge的区别</li>
</ol>
<p>变基是清理分支提交历史，合并会保留分支的提交历史</p>
<ol start="4">
<li>举例</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 0. 前提：当前master分支</span><br><span class="line">&gt; 1. 新建分支dev并作提交：</span><br><span class="line">&gt; git checkout -b dev</span><br><span class="line">&gt; git cm -a -m “comment”</span><br><span class="line">&gt; 2. 切回master分支并作提交</span><br><span class="line">&gt; git checkout master</span><br><span class="line">&gt; git cm -a -m “comment”</span><br><span class="line">&gt; 3. 此时两个分支分叉了，将dev分支的修改干净的合并到master分支：</span><br><span class="line">&gt; git checkout dev</span><br><span class="line">&gt; git rebase master</span><br><span class="line">&gt; git checkout master</span><br><span class="line">&gt; git merge dev </span><br><span class="line">&gt; 4. 此时dev分支的所有提交历史都没有了，但是dev的所有修改都合并到了masger分支</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li>
<p>cherry-pick</p>
<blockquote>
<p>在某个特性分支上进行开发，进行了多次提交，此时只想将特性分支上的某个提交合并进主分支，即可使用cherry-pick</p>
<p>在主分支上：git cherry-pick commitNo</p>
</blockquote>
</li>
<li>
<p>reflog</p>
<blockquote>
<p>reflow 引用日志：一份记录最近几个月你的 HEAD 和分支引用的日志</p>
<p>git reflog</p>
</blockquote>
</li>
<li>
<p>stash</p>
<p>经常有这样的事情发生，当你正在进行项目中某一部分的工作，里面的东西处于一个比较杂乱的状态，而你想转到其他分支上进行一些工作。问题是，你不想提交进行了一半的工作，否则以后你无法回到这个工作点。解决这个问题的办法就是git stash命令</p>
<blockquote>
<p>git stash</p>
<p>git stash list</p>
<p>git stash apply stash@{0}</p>
<p>git stash branch stashBranchName (基于储藏工作时的所处的提交创建一个新分支)</p>
</blockquote>
</li>
<li>
<p>重写提交历史（基于本地提交，push到远端仓库的提交不宜再进行重写，容易引起混乱）</p>
<blockquote>
<p>重写最近一次的提交历史：git commit --amend</p>
<p>交互式重写最近n次的提交历史（合并，删除，调整次序）：git rebase -i HEAD~n</p>
<p>全局性更改提交者名称和电子邮件地址：（注意将修改push到仓库，会读取git config的配置，所以最好保持此处的name 和 email和git config的一致）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; git filter-branch --commit-filter &apos;</span><br><span class="line">&gt;  if [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;gaga@GaGadeBook.lan&quot; ];</span><br><span class="line">&gt;  then</span><br><span class="line">&gt;          GIT_AUTHOR_NAME=&quot;localGa&quot;;</span><br><span class="line">&gt;          GIT_AUTHOR_EMAIL=&quot;localGa@docker.com&quot;;</span><br><span class="line">&gt;          git commit-tree &quot;$@&quot;;</span><br><span class="line">&gt;  else</span><br><span class="line">&gt;          git commit-tree &quot;$@&quot;;</span><br><span class="line">&gt;  fi&apos; HEAD</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li>
<p>文件标注：查看文件的每一行对应的最后一次提交信息</p>
<p>git blame fileName</p>
</li>
<li>
<p>子模块：允许你将一个 Git 仓库当作另外一个Git仓库的子目录。这允许你克隆另外一个仓库到你的项目中并且保持你的提交在两个git仓库相对独立。</p>
<blockquote>
<p>子模块应用场景：</p>
<p>当你在一个项目上工作时，你需要在其中使用另外一个项目。也许它是一个第三方开发的库或者是你独立开发和并在多个父项目中使用的。这个场景下一个常见的问题产生了：你想将两个项目单独处理但是又需要在其中一个中使用另外一个。</p>
<p>git submodule add  repourl （此时会创建一个相应的子目录 和 .gitmodules文件，git操作在子目录和外层目录是独立的。在外层项目中，把子目录当作一个特殊文件处理，每次子目录有新的提交变更时，外层目录会看到相应的子目录特殊文件有修改）</p>
<p>当你克隆一个带子模块的项目时，你将得到包含子项目的目录，但里面是空的没有文件，此时还需要运行：git submodule init &amp; git submodule update 来初始化配置并拉取子项目文件</p>
<p>但是在带子模块的项目里切换分支需要额外多余的操作很麻烦</p>
</blockquote>
</li>
<li>
<p>子树归并：处理子项目的另一种方式：以分支合并的方式来添加子项目</p>
<blockquote>
<p>子树归并的思想是你拥有两个工程，其中一个项目映射到另外一个项目的子目录中</p>
<p>比如将learnGit项目添加进CalendarServer作为子项目：</p>
<ol>
<li>git remote add learnGit <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:qiaojianqj/learnGit.git （添加远程仓库）</li>
<li>git fetch learnGit （获取远程仓库配置分支信息）</li>
<li>git checkout -b learngit learnGit/master （以新添加的远程仓库master分支建立本地分支learngit）</li>
<li>git checkout master （切换回CalendarServer项目本地分支）</li>
<li>git read-tree --prefix=learngit/ -u learngit （拉取learngit分支到master分支的learngit目录，作为子项目）</li>
</ol>
</blockquote>
</li>
</ol>
<h2 id="git-hook">git hook</h2>
<p>在git项目的.git/hooks目录下存放有钩子脚本，在特定git命令执行前后会被调用，实现自定义逻辑</p>
<p>默认脚本以.sample结尾，不起作用，去掉.sample使得钩子命令生效</p>
<h2 id="git-svn">git svn</h2>
<p>git svn 命令集用于 git客户端和svn服务端交互，以及将svn仓库迁徙至git仓库</p>
<h2 id="git-手册">git 手册</h2>
<p><a href="https://git-scm.com/book/zh/v1/" target="_blank" rel="noopener">https://git-scm.com/book/zh/v1/</a></p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>java1.8-HashMap</title>
    <url>/article/java1-8-HashMap/</url>
    <content><![CDATA[<h3 id="类文件说明">类文件说明</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我们知道java sdk里的注释是最好的doc文档。每个源码文件开始都有一大段注释来说明此文件所描述的内容，在这儿我们可以对源码有个大概的了解。</span><br></pre></td></tr></table></figure>
<p><strong>一：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HashMap和HashTable类似，不同之处在于HashMap是非同步的即不是线程安全的；HashMap允许key、value为null</span><br></pre></td></tr></table></figure>
<p><strong>二：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HashMap不保证插入元素所存放的顺序，甚至不保证元素的存放顺序会一直保持不变</span><br></pre></td></tr></table></figure>
<p><strong>三：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">假定hash函数散列性能比较好，基本的get、put操作都是O(1) 性能。对Map的遍历操作性能则和Map的capacity(桶深)、size（键值对个数）成比例，所以如果对遍历性能要求比较高的话，则不要将initial capacity设置太高，也不要将loadFactor设置过低</span><br></pre></td></tr></table></figure>
<p><strong>四：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HashMap有两个重要的影响性能的参数：initial capacity和loadFactor。initial capacity是哈希表创建时哈希数组的初始大小。loadFactor(负载因子)是哈希表自动扩容前所允许哈希数组的已使用容量，当已使用容量超过loadFactor时，哈希表自动扩容到两倍之前的capacity，重新构建内部结构。loadFactor为0.75时，时间空间复杂度最好。loadFactor大于0.75时，空间消耗少，时间消耗增加。loadFactor小于0.75时，空间消耗增加，时间消耗少。所以在初始化HashMap时要根据loadFactor来设置initial capacity，以减少扩容(影响性能)的次数。</span><br></pre></td></tr></table></figure>
<p><strong>五：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HashMap是通过key的hashcode来确定所对应的存放bucket，所以为了HashMap的性能，需要让key的hashcode尽量不重复</span><br></pre></td></tr></table></figure>
<p><strong>六：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HashMap不是线程安全的，所以有多个线程同时访问同一个HashMap时，如果至少有一个线程修改了HashMap的结构(增加或删除元素等操作)，则需要对这个HashMap加上Synchronized同步。一个使HashMap成为线程安全的方法如下：</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Map m = Collections.synchronizedMap(new HashMap(...));</span><br></pre></td></tr></table></figure>
<p><strong>七：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在HashMap上取Iterator之后，如果不是通过Iterator自己的方法来改变HashMap的结构（增加或删除元素等操作），Iterator将会失效，后续基于Iterator的代码将会抛异常：java.util.ConcurrentModificationException。</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  Map&lt;String, String&gt; employers = <span class="keyword">new</span> HashMap&lt;&gt; (  );</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        employers.put ( <span class="string">"1"</span>, <span class="string">"qiaojian"</span> );</span><br><span class="line">        employers.put ( <span class="string">"2"</span>, <span class="string">"leo"</span> );</span><br><span class="line">        employers.put ( <span class="string">"3"</span>, <span class="string">"guo"</span> );</span><br><span class="line">        employers.put ( <span class="string">"4"</span>, <span class="string">"min"</span> );</span><br><span class="line"></span><br><span class="line">        Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iter = employers.entrySet ().iterator ();</span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext ()) &#123;</span><br><span class="line">            employers.put ( <span class="string">"5"</span>, <span class="string">"bab"</span> ); <span class="comment">//此行代码导致抛出异常</span></span><br><span class="line">            Map.Entry&lt;String, String&gt; next = iter.next ();</span><br><span class="line">            <span class="keyword">if</span> (next.getKey ().equals ( <span class="string">"2"</span> )) &#123;</span><br><span class="line">                iter.remove (); <span class="comment">//通过Iterator自己的方法删除元素是正确的</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println ( employers.size () );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="serialversionuid">serialVersionUID</h3>
<p><code>serialVersionUID</code> 用来表明类的不同版本间的兼容性。</p>
<p>对于实现了Serializable接口的类表示此类可以被序列化和反序列化。</p>
<p><code>serialVersionUID</code>是根据类名、接口名、成员方法及属性等来生成一个64位的哈希字段。</p>
<p>Java的反序列化即是通过传过来的<code>serialVersionUID</code>和本地定义的类的<code>serialVersionUID</code>作比对来确保反序列化的正确性。</p>
<p>显示的定义<code>serialVersionUID</code>可以在反序列化时，确保类版本的兼容性。即使某个类在与之对应的对象已经序列化出去后做了修改，该对象依然可以被正确反序列化（当<code>serialVersionUID</code>相同时，它就会将不一样的field以type的预设值Deserialize，确保兼容性）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">关于HashMap的序列化</span><br><span class="line">1. 首先 HashMap 实现了 Serializable 接口，可以序列化</span><br><span class="line">2. serialVersionUID 用于保证版本的兼容性</span><br><span class="line">3. static和final属性不会被序列化</span><br><span class="line">4. transient修饰的属性不会被序列化</span><br><span class="line">5. HashMap的 table、entrySet、size和modCount属性都被标记为transient</span><br><span class="line">6. HashMap实现了自己的序列化方法: writeObject 和反序列化方法 readObject，表示不会使用JDK中默认的序列化方法</span><br><span class="line">7. Java的序列化使用ObjectOutputStream类的各种方法（writeInt、writeBoolean、writeObject等），反序列化使用ObjectInputStream的各种方法（readInt、readBoolean、readObject等），而writeObject和readObject会判断被序列化对象是否重写了对应的方法来调用被序列化对象自己的方法完成自定义的序列化和反序列化</span><br><span class="line">8. HashMap为什么要自己实现序列化和反序列化方法？ 因为HashMap中，由于Entry的存放位置是根据Key的Hash值来计算，然后存放到数组中的，对于同一个Key，在不同的JVM实现中计算得出的Hash值可能是不同的。而Key的Hash值不同会导致table结构的不同，导致JDK默认序列化出来的数据也不同。而HashMap自定义的序列化方法writeObject中将table里每个Node的key和value分别序列化。在自定义的反序列化方法readObject中将key、value提取出来重新计算hash，重新put形成table</span><br></pre></td></tr></table></figure>
<h3 id="tablesizefor">tableSizeFor</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> * 此函数的作用是：根据当前传入的cap，计算出table size（为2的幂次方，等于 capacity * loadfactor）</span></span><br><span class="line"><span class="comment"> * 比如：new Hashmap&lt;&gt; (5); 则根据5计算出 table size为8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">  <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为什么要保持table size是2的幂次方？</span></span><br><span class="line"><span class="comment">//因为：在put元素时是根据（hash(key) % capacity）来确定元素要存放的index：</span></span><br><span class="line"><span class="comment">//而：取余(%)操作中如果除数是2的幂次方则等同于与其除数减一的与(&amp;)操作。</span></span><br><span class="line"><span class="comment">//所以上式等同于下式</span></span><br><span class="line">index = e.hash % newCap</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">index = e.hash &amp; (newCap - <span class="number">1</span>);</span><br><span class="line"><span class="comment">//所以保持table size是2的幂次方是为了根据hash来计算index可以通过&amp;运算完成以提供性能</span></span><br></pre></td></tr></table></figure>
<h3 id="hashkey">hash(key)</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//由下可见，在put元素时，根据key计算hash值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//hash值的计算规则：取key的hashCode与其自身的高16位进行异或运算</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> h;</span><br><span class="line">  <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为什么hash计算要取key的hashCode与其自身的高16位进行异或运算？</span></span><br><span class="line"><span class="comment">//因为上面我们提到index的运算规则是e.hash &amp; (newCap - 1)。</span></span><br><span class="line"><span class="comment">//由于newCap是2的幂次方，那么newCap - 1的高位应该为0。</span></span><br><span class="line"><span class="comment">//如果e.hash值只用自身的hashcode的话，那么newCap - 1只会和e.hash低位做&amp;操作(e.hash有32位值，而newCap - 1 通常没有那么大)。这样一来，e.hash的值就只有低位参与运算，高位未参与计算，从而会带来哈希冲突的风险。</span></span><br><span class="line"><span class="comment">//所以在计算key的哈希值的时候，用其自身hashcode值与其高16位做异或操作。这也就让高位参与到index的计算中来了，即降低了哈希冲突的风险又不会带来太大的性能问题。</span></span><br></pre></td></tr></table></figure>
<h3 id="nodelt-k-v-gt">Node&lt; K ,V &gt;[]</h3>
<p><code>Node&lt;K,V&gt;[] table</code>是<code>HashMap</code>底层存储的数据结构，是一个<code>Node</code>数组。<code>Node</code>类为元素维护了一个单向链表。这样设计的原因是考虑到遇到哈希冲突的时候，同<code>index</code>的<code>value</code>值就用单向链表来维护。当单链表的长度超过<code>TREEIFY_THRESHOLD</code> (默认8)时，将内部结构单链表转为红黑树存储，红黑树节点由Node的子类TreeNode表示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">  <span class="keyword">final</span> K key;</span><br><span class="line">  V value;</span><br><span class="line">  Node&lt;K,V&gt; next; <span class="comment">//单链表</span></span><br><span class="line">  ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构造函数">构造函数</h3>
<p>由下可知<code>HashMap</code>一共有四个构造函数：均未在构造函数里初始化hash table数组，只是设置属性：</p>
<p><code>loadFactor</code>  和 <code>threshhold</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                       initialCapacity);</span><br><span class="line">  <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">    initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">  <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                       loadFactor);</span><br><span class="line">  <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">  <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">  putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="resize">resize()</h3>
<p>在put元素时会根据table是否为空来初始化table，或者在put元素后根据table的元素size是否超过<code>threshold</code>来扩容。而初始化table和对table进行扩容均是通过resize()实现的。如果table为null，则将threshold里的值作为initial capacity来初始化table。table不为空，则进行table size加倍扩容。由于使用的幂扩展，扩容后新table里的元素要么维持原来的index不变，要么index移动2的幂次方(oldCap)。</p>
<p><img src="https://qiaojiande-1259482780.cos.ap-chengdu.myqcloud.com/hashmap-resize.jpg" alt="hashmap-resize"></p>
<h3 id="modcount">modCount</h3>
<p>modCount记录HashMap结构化改变的次数，用于Iterator遍历HashMap时的并发修改异常探测(仅是do the best 不是绝对可靠，因为没加锁。。。)<br>
Iterator的时候，每次遍历取Next，或执行remvoe的时候都要去检测modCount和Iterator初始化时的expectModCount相同，不同则会抛异常ConcurrentModificationException<br>
同时，通过Iterator的remove方法在遍历的时候去删除元素会同时修改modCount和Iterator的expectModCount，所以没有问题(do the best)<br>
Fast-Fail Iterator &amp; Fail-Safe Iterator<br>
Fast-Fail Iterator: 在iterator遍历时，不通过iterator的结构修改会抛异常ConcurrentModificationException<br>
Fail-Safe Iterator：在iterator遍历时，可以不通过iterator来修改集合的结构，不会抛异常<br>
JDK中使用Fast-Fail模式的集合：ArrayList、HashMap、Vector等<br>
JDK中使用Fail-Safe模式的集合：ConcurrentHashMap、CopyOnWriteAraayList</p>
<h3 id="put">put</h3>
<p><img src="https://qiaojiande-1259482780.cos.ap-chengdu.myqcloud.com/201908/hashmap-put.jpg" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//LinkedHashMap 移除旧节点示例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// LinkedHashMap removeEldestEntry() 默认实现返回false，不起作用</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> MAX = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造匿名类继承自LinkedHashMap，并实现removeEldestEntry，每次插入节点时检测大小超过阈值，则自动删除旧节点</span></span><br><span class="line">  LinkedHashMap&lt;Integer, String&gt; li_hash_map =</span><br><span class="line">    <span class="keyword">new</span> LinkedHashMap&lt;Integer, String&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;Integer, String&gt; eldest)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> size() &gt; MAX;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 插入2个节点</span></span><br><span class="line">  li_hash_map.put(<span class="number">1</span>, <span class="string">"One"</span>);</span><br><span class="line">  li_hash_map.put(<span class="number">2</span>, <span class="string">"Two"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//&#123;1=One, 2=Two&#125;</span></span><br><span class="line">  System.out.println(<span class="string">""</span> + li_hash_map);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 插入第三个节点，超出阈值</span></span><br><span class="line">  li_hash_map.put(<span class="number">3</span>, <span class="string">"Three"</span>);</span><br><span class="line">  <span class="comment">//&#123;2=Two, 3=Three&#125;</span></span><br><span class="line">  System.out.println(<span class="string">""</span> + li_hash_map);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 插入第四个节点，超出阈值</span></span><br><span class="line">  li_hash_map.put(<span class="number">4</span>, <span class="string">"Four"</span>);</span><br><span class="line">  <span class="comment">//&#123;3=Three, 4=Four&#125;</span></span><br><span class="line">  System.out.println(<span class="string">""</span> + li_hash_map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="get">get</h3>
<p><img src="https://qiaojiande-1259482780.cos.ap-chengdu.myqcloud.com/201908/hashmap-get.jpg" alt=""></p>
<p>首先根据key计算hash，然后通过hash与table length取余运算得出key-value所在的table的index，取出index处的key-value，再比较key，若没找到，再遍历链表比较。注意图中1和2处key的比较，使用 == 和 equals，表示HashMap的两个key相等的判断条件是：同样的key对象或者自定义的key.equals相等。由此也可直达作为HashMap的Key对象必须实现hashCode方法和equals方法。hashCode用于确定key-value在数组中的index，equals用于比较查找key-value。</p>
<h3 id="链表转红黑树">链表转红黑树</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//链表长度超过8时，转红黑树</span><br><span class="line">final void treeifyBin(java.util.HashMap.Node&lt;K,V&gt;[] tab, int hash) &#123;</span><br><span class="line">    int n, index; java.util.HashMap.Node&lt;K,V&gt; e;</span><br><span class="line">    if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        // 数组大小小于64，则走扩容，扩容数组至2倍原来大小</span><br><span class="line">        resize();</span><br><span class="line">    //找到链表头节点</span><br><span class="line">    else if ((e = tab[index = (n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">        //遍历Node链表，将Node链表元素转TreeNode链表</span><br><span class="line">        java.util.HashMap.TreeNode&lt;K,V&gt; hd = null, tl = null;</span><br><span class="line">        do &#123;</span><br><span class="line">            //调用replacementTreeNode，根据Node链表节点构造TreeNode节点</span><br><span class="line">            java.util.HashMap.TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);</span><br><span class="line">            if (tl == null)</span><br><span class="line">                //TreeNode链表为空，则将TreeNode节点设置为首节点</span><br><span class="line">                hd = p;</span><br><span class="line">            else &#123;</span><br><span class="line">                //TreeNode链表不为空，则向TreeNode链表后添加TreeNode元素</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; while ((e = e.next) != null);</span><br><span class="line">        if ((tab[index] = hd) != null)</span><br><span class="line">            //hd即是TreeNode链表，调用treeify将TreeNode链表转为红黑树</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于红黑树：是一颗自平衡二叉树，通过它的5个特性限制确保了红黑树的关键特性：从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。提升查找性能，它可以在O(logn)时间内完成查找，插入和删除，这里的n是树中元素的数目。</p>
<ol>
<li>节点是红色或黑色。</li>
<li>根是黑色。</li>
<li>所有叶子都是黑色（叶子是NIL节点）。</li>
<li>每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）</li>
<li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。</li>
</ol>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java-基础</title>
    <url>/article/java-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="数据类型">数据类型</h3>
<p>byte(1字节), short(2字节), int(4字节), long(8字节), float(4字节), double(8字节), char(2字节), boolean(true, false)</p>
<p>Java 没有任何无符号(unsigned) 形式的 int、long、short 或 byte 类型。</p>
<p>char 类型描述了 UTF-16 编码中的一个代码单元，占2字节，（有的字符编码占用两个代码单元）建议不要在程序中使用 char 类型。</p>
<p>整数被 0 除将会产生一个异常， 而浮点数被 0 除将会得到无穷大或 NaN 结果。</p>
<p>&amp;&amp;和||运算符是按照“ 短路”方式来求值的: 如果第一个操作数已经能够确定表达式的值，第二个操作数就不必计算了。</p>
<p>&gt;&gt;运算符会用符号位填充高位，&gt;&gt;&gt;运算符会用 0 填充高位。</p>
<p>移位运算符的右操作数要完成模32的运算(除非左操作数是long类型，在这种情况下需要对右操作数模 64 )。 例如，1&lt;&lt;35 的值等同于 1&lt;&lt;3 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println ( <span class="number">1.0</span> / <span class="number">0</span> );</span><br><span class="line"><span class="comment">//output Infinity</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> valInt = <span class="number">1</span>&lt;&lt;<span class="number">35</span>;</span><br><span class="line">System.out.println ( valInt);</span><br><span class="line"><span class="comment">//output 8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> valLong = (<span class="keyword">long</span>)<span class="number">1</span>&lt;&lt;<span class="number">35</span>;</span><br><span class="line">System.out.println ( valLong );</span><br><span class="line"><span class="comment">//output 34359738368</span></span><br></pre></td></tr></table></figure>
<p>字符串“xxoo”是unicode字符x、x、o、o组成的序列。字符串、String类对象是不可变对象。</p>
<p>判断字符串内容相等用equals，==运算符是判断字符串的地址是否相等。</p>
<p>String取length是取的字符串的代码单元的个数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String hehe = <span class="string">"😄"</span>;</span><br><span class="line">System.out.println ( hehe.length () ); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>Console类用于输入密码，为了安全起见，返回的密码存放在一维字符数组中， 而不是字符串中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">因为字符串有字符串常量池，导致密码长期保存在内存中，容易通过jmap+jhat分析出密码来，而使用字符数组，用完即可置为null，相对安全</span><br></pre></td></tr></table></figure>
<p>在 C++ 中， 可以在嵌套的块中重定义一个变量。 在内层定义的变量会覆盖在外层定义的变量。 但是，在java中不允许嵌套块中重定义外层的变量。</p>
<p>在 Java 中， 允许数组长度为 0。 在 Java 中， 允许将一个数组变量拷贝给 另一个数组变量。这时， 两个变量将引用同 一个数组。如果希望将 一个数组的所有值拷贝到一个新的数组中去， 就要使用 Arrays 类的 copyOf 方法。可以通过二维数组创建不规则数组（先创建行，再单独创建每行的数组）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//浮点数默认为双精度的（double）</span></span><br><span class="line"><span class="comment">//float i = 1.1;</span></span><br><span class="line"><span class="keyword">float</span> i = (<span class="keyword">float</span>) <span class="number">1.1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">short</span> j = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//整型默认为int</span></span><br><span class="line"><span class="comment">//j = j + 1;</span></span><br><span class="line"><span class="comment">// += 运算自动向下转型 int -&gt; short</span></span><br><span class="line">j += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不使用临时变量交换两个整数的值</span></span><br><span class="line"><span class="comment">//方法1. 使用异或操作swap a 和 b 的值</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">456</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">123</span>;</span><br><span class="line">a = a ^ b;</span><br><span class="line">b = a ^ b;</span><br><span class="line">a = a ^ b;</span><br><span class="line">System.out.println ( a ); <span class="comment">//123</span></span><br><span class="line">System.out.println ( b ); <span class="comment">//456</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法2. 使用加减法运算</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">456</span>;</span><br><span class="line">a = a + b;</span><br><span class="line">b = a - b;</span><br><span class="line">a = a - b;</span><br><span class="line">System.out.println ( a );</span><br><span class="line">System.out.println ( b );</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译时能确定的String对象都放入常量池</span></span><br><span class="line"><span class="comment">//运行时才能确定或者new出的String对象都放入堆</span></span><br><span class="line">String str1 = <span class="string">"I am String1"</span>; <span class="comment">//变量str1引用指向字符串常量池</span></span><br><span class="line"><span class="keyword">final</span> String str2 = <span class="string">"I am String"</span>; <span class="comment">//final修饰，str2是编译期常量</span></span><br><span class="line">String str3 = <span class="string">"I am String"</span>; <span class="comment">//变量str3引用指向字符串常量池</span></span><br><span class="line">String str4 = str2 + <span class="number">1</span>; <span class="comment">// str2 + 1 得到的也是个常量，放在常量池</span></span><br><span class="line">String str5 = str3 + <span class="number">1</span>; <span class="comment">// str3 + 1 得到的是个变量，放在堆上 （因为str3变量在运行时才可以取到它所引用的值）</span></span><br><span class="line">System.out.println ( str1 == str4 );</span><br><span class="line">System.out.println ( str1 == str5 );</span><br><span class="line"></span><br><span class="line"><span class="comment">//try语句带return，finally执行时机</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (a == <span class="number">123</span>) &#123;</span><br><span class="line">     System.out.println ( <span class="string">"in try return a = "</span> + a );</span><br><span class="line">     <span class="keyword">return</span>; <span class="comment">// 执行到此处，记录return的值，然后执行finally代码块，再然后return</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"> a = <span class="number">1234</span>;</span><br><span class="line"> System.out.println ( <span class="string">"in finally a = "</span> + a );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类和对象">类和对象</h3>
<p>识别类的简单规则是在分析问题的过程中寻找名词， 而方法对应着动词。</p>
<table>
<thead>
<tr>
<th>关系</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>继承(is a)</td>
<td>is a，类A扩展自类B</td>
</tr>
<tr>
<td>接口实现</td>
<td>类实现接口中的方法</td>
</tr>
<tr>
<td>依赖(use a)</td>
<td>use a，一个类的方法操纵另一个类的对象</td>
</tr>
<tr>
<td>聚合(has a)</td>
<td>has a，类A的对象包含类B的对象（属性关联）</td>
</tr>
<tr>
<td>关联</td>
<td>通过属性、方法关联</td>
</tr>
</tbody>
</table>
<p>构造器总是伴随着 new 操作符的执行被调用。</p>
<p>不要编写返回引用可变数据域对象的访问器方法。 如果需要返回一个可变数据域的拷贝， 就应该使用 clone。</p>
<ol>
<li>Get不使用clone，直接返回引用</li>
</ol>
<p><img src="https://qiaojiande-1259482780.cos.ap-chengdu.myqcloud.com/201908/java-base-get-return-ref-1.jpg" alt=""></p>
<ol start="2">
<li>Get返回引用对象的clone</li>
</ol>
<p><img src="https://qiaojiande-1259482780.cos.ap-chengdu.myqcloud.com/201908/java-base-get-return-ref-2.jpg" alt=""></p>
<p>对于可变的类， 使用 final 修饰符可能会对读者造成混乱。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span>  StringBuilder evaluations;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">     evaluations = <span class="keyword">new</span> StringBuilder (  );</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//final 关键字只是表示存储在 evaluations 变量中的对象引用不会再指示其他 StringBuilder 对象。 不过这个对象可以更改</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveGoldStar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     evaluations.append ( <span class="keyword">new</span> Date () + <span class="string">": Gold Star!\n"</span> );</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">printTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     System.out.println ( evaluations );</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态变量使用得比较少， 但静态常量(static final)却使用得比较多。 静态方法是没有this参数的方法，在一个非静态方法中this参数是该方法的隐式参数，代表操作此方法的对象。</p>
<p>java方法调用参数是按值传递，下面总结一下 Java 中方法参数的使用情况:</p>
<p>• 一个方法不能修改一个基本数据类型的参数 (即数值型或布尔型)。</p>
<p>• 一个方法可以改变一个对象参数的状态。</p>
<p>• 一个方法不能让对象参数引用一个新的对象。</p>
<p>类属性与局部变量的主要不同点： 必须明确地初始化方法中的局部变量。 但是，如果没有初始化类中的属性， 它将会被自动初始化为默认值(0、false 或 null )，但是，这并不是一种良好的编程习惯。</p>
<p>仅当类没有提供任何构造器的时候，系统才会提供一个默认的构造器 。</p>
<p>可以在类定义中， 直接将一个值赋给任何属性。在执行构造器之前，将会先执行赋值操作。</p>
<p>类构造初始化次序：</p>
<ol>
<li>static 属性赋值</li>
<li>static 初始化块</li>
<li>实例属性赋值</li>
<li>实例属性初始化块</li>
<li>构造函数体</li>
</ol>
<p>可以为任何一个类添加 finalize 方法。finalize 方法将在垃圾回收器清除对象之前调用。 在实际应用中， 不要依赖于使用 finalize 方法回收任何短缺的资源，这是因为很难知道这个方法什么时候才能够调用。</p>
<p>从编译器的角度来看，嵌套的包之间没有任何关系。 例如， java.util 包与 java.util.jar 包毫无关系。每一个都拥有独立的类集合。</p>
<p>将包中的文件放到与完整的包名匹配的子目录中。</p>
<p>利用 -classpath 选项设置类路径是首选的方法， 也可以通过设置 CLASSPATH 环境变量 完成这个操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -classpath c:\classdir;.;c:\archives\archive.jar MyProg</span><br><span class="line">//或者</span><br><span class="line">export CLASSPATH=/home/user/classdir:.:/home/user/archives/archive.jar</span><br></pre></td></tr></table></figure>
<h3 id="继承">继承</h3>
<p>如果子类的构造器没有显式地调用超类的构造器，则将自动地调用超类默认(没有参数 ) 的构造器。 如果超类没有不带参数的构造器，并且在子类的构造器中又没有显式地调用超类的其他构造器， 则 Java 编译器将报告错误。</p>
<p>是否应该设计为继承关系的一个简单规则： “is-a” 规则。它的另一种表述法是置换法则。它表明程序中出现超类对象的任何地方都可以用子类对象置换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Employee e;</span><br><span class="line">e = <span class="keyword">new</span> Employee();</span><br><span class="line">e = <span class="keyword">new</span> Manager(); <span class="comment">//ok, Manager extends from Employee</span></span><br></pre></td></tr></table></figure>
<p>在 Java 中，子类数组的引用可以转换成超类数组的引用，而不需要采用强制类型转换。但是一定要注意这种用法会引起以下类型紊乱的错误。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Manager[] managers = <span class="keyword">new</span> Manager[<span class="number">10</span>];</span><br><span class="line">Employee[] staff = managers; <span class="comment">//ok, but now staff and managers reference to the same Objects</span></span><br><span class="line">staff[<span class="number">0</span>] = <span class="keyword">new</span> Employee(); <span class="comment">//ok</span></span><br><span class="line">managers[<span class="number">0</span>].setBonus(<span class="number">1000</span>); <span class="comment">//error, this will arise ArrayStoreException</span></span><br></pre></td></tr></table></figure>
<p>返回类型不是签名的一部分， 因此，在覆盖方法时，一定要保证返回类型的兼容性。允许子类将覆盖方法的返回类型定义为原返回类型的子类型。</p>
<p>方法调用的两种方式：静态绑定（private方法、static方法、final方法），动态绑定（其他）</p>
<p>如果将一个类声明为 final， 只有其中的方法自动地成为 final, 而不包括属性。</p>
<p>只能在继承层次内进行类型转换。 在将超类转换成子类之前，应该使用 instanceof 进行检查。 但是尽量不要使用类型转换，如果必须使用类型转换，则应该检查超类的设计是否合理。</p>
<p>包含一个或多个抽象方法的类本身必须被声明为抽象的。 但是，类即使不含抽象方法， 也可以将类声明为抽象类。</p>
<p>在 Java 中，只有基本类型 ( primitive types ) 不是对象， 所有的数组类型，不管是对象数组还是基本类型的数组都是扩展自Object的类对象。</p>
<p>为一个类编写equals方法的完美建议：</p>
<blockquote>
<ol>
<li>显示参数命名为otherObject</li>
<li>检测this与otheObject是否引用同一对象：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">if</span> (<span class="keyword">this</span> == otherObject) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<ol start="3">
<li>检测otherObject是否为null</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">if</span> (otherObject == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<ol start="4">
<li>检测this与otherObject是否属于同一个类：</li>
</ol>
<p>如果equals的语义在每个子类有所改变，则使用getClass检测</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">if</span> (getClass() != otherObject.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>如果所有子类使用相同的语义，即由超类决定相等的概念，则使用instanceof检测</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">if</span> (!(otherObject <span class="keyword">instanceof</span> ClassName)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<ol start="5">
<li>将otherObject转换为相应的类类型变量</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; ClassName other = (ClassName) otherObject;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<ol start="6">
<li>开始属性域的比较，使用==比较基本类型，使用Objects.equals比较对象</li>
</ol>
</blockquote>
<p>如果重新定义 equals 方法， 就必须重新定义 hashCode 方法。</p>
<p>强烈建议为自定义的每一个类增加toString方法。</p>
<p>对象包装器类（Integer，Long，Float，Double，Short，Byte，Character，Void，Boolean）是final类, 因此不能定义它们的子类。</p>
<p>自动装箱规范要求 介于 -128 ~ 127 之间的byte,  short , int, char(0~127) 被包装到固定的对象中(ByteCache,ShortCache,IntegerCache,CharacterCache)。 因此</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer a = <span class="number">1000</span>;</span><br><span class="line">Integer b = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">if</span> (a == b) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">Integer a = <span class="number">100</span>;</span><br><span class="line">Integer b = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">if</span> (a == b) <span class="comment">// true</span></span><br><span class="line">  </span><br><span class="line">System.out.println ( <span class="string">"--------Short--------"</span> );</span><br><span class="line"></span><br><span class="line">Short s1 = <span class="number">12</span>;</span><br><span class="line">Short s2 = <span class="number">12</span>;</span><br><span class="line">Short s3 = <span class="number">129</span>;</span><br><span class="line">Short s4 = <span class="number">129</span>;</span><br><span class="line">System.out.println ( s1 == s2 ); <span class="comment">//true</span></span><br><span class="line">System.out.println ( s3 == s4 ); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">System.out.println ( <span class="string">"--------Byte--------"</span> );</span><br><span class="line"></span><br><span class="line">Byte b1 = <span class="number">13</span>;</span><br><span class="line">Byte b2 = <span class="number">13</span>;</span><br><span class="line">Byte b3 = <span class="number">127</span>;</span><br><span class="line">Byte b4 = <span class="number">127</span>;</span><br><span class="line">System.out.println ( b1 == b2 ); <span class="comment">//true</span></span><br><span class="line">System.out.println ( b3 == b4 ); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">System.out.println ( <span class="string">"--------Character--------"</span> );</span><br><span class="line"></span><br><span class="line">Character c1 = <span class="number">56</span>;</span><br><span class="line">Character c2 = <span class="number">56</span>;</span><br><span class="line">Character c3 = <span class="number">156</span>;</span><br><span class="line">Character c4 = <span class="number">156</span>;</span><br><span class="line">System.out.println ( c1 == c2 ); <span class="comment">//true</span></span><br><span class="line">System.out.println ( c3 == c4 ); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>自动装箱拆箱陷阱</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer a = <span class="number">1</span>;</span><br><span class="line">Integer b = <span class="number">2</span>;</span><br><span class="line">Integer c = <span class="number">3</span>;</span><br><span class="line">Integer e = <span class="number">321</span>;</span><br><span class="line">Integer e1 = <span class="number">300</span>;</span><br><span class="line">Integer e2 = <span class="number">21</span>;</span><br><span class="line">Long g = <span class="number">3L</span>;</span><br><span class="line">System.out.println ( e == (e1+e2) ); <span class="comment">//true == 在遇到算术运算后，自动拆箱，比较值相等</span></span><br><span class="line">System.out.println ( c.equals ( a+b ) ); <span class="comment">//true a+b 算术运算后，自动装箱为Integer</span></span><br><span class="line">System.out.println ( g == (a+b) ); <span class="comment">// true a+b 算术运算后，自动拆箱为 3</span></span><br><span class="line">System.out.println ( g.equals ( a+b ) ); <span class="comment">//false equals方法不会处理数据类型转换的关系</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql笔记</title>
    <url>/article/mysql%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="查看mysql-用户的连接权限">查看mysql 用户的连接权限</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; use mysql;</span><br><span class="line">Reading table information for completion of table and column names</span><br><span class="line">You can turn off this feature to get a quicker startup with -A</span><br><span class="line"></span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; select host , user  from user;</span><br><span class="line">+-----------+---------------+</span><br><span class="line">| host      | user          |</span><br><span class="line">+-----------+---------------+</span><br><span class="line">| %         | root          |</span><br><span class="line">| localhost | mysql.session |</span><br><span class="line">| localhost | mysql.sys     |</span><br><span class="line">| localhost | root          |</span><br><span class="line">+-----------+---------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>可见允许root用户在任何IP段下连接数据库实例</p>
<h3 id="mysql连接方式">mysql连接方式</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. TCP/IP方式：本地或远程登录</span><br><span class="line">mysql -hhost -uname -ppassword</span><br><span class="line">2. socket方式：本地登录</span><br><span class="line">[root@localhost ~]# ps -ef | grep mysql</span><br><span class="line">root      3076     1  0 Oct14 ?        00:00:00 /bin/sh /usr/bin/mysqld_safe --datadir=/var/lib/mysql --socket=/var/lib/mysql/mysql.sock --pid-file=/var/run/mysqld/mysqld.pid --basedir=/usr --user=mysql</span><br><span class="line">mysql -uname -S/var/lib/mysql/mysql.sock</span><br></pre></td></tr></table></figure>
<h3 id="innodb-存储结构b树">InnoDB 存储结构：B+树</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">InnoDB的一张表的数据和索引都存在表空间，一个表空间对应一个ibd文件</span><br><span class="line"></span><br><span class="line">表空间由段、区、页组成</span><br><span class="line">段由多个区组成</span><br><span class="line">区由连续的多个页组成（页大小默认为16KB）</span><br><span class="line">页存放table的行数据</span><br><span class="line"></span><br><span class="line">B+树叶子节点：存储 数据段</span><br><span class="line">B+树非叶子节点：存储 索引段</span><br></pre></td></tr></table></figure>
<h3 id="索引">索引</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 聚集索引：</span><br><span class="line">一张表只有一个聚集索引，因为InnoDB的数据存储就是按照主键顺序存放的一颗B+树，此时B+树的叶子节点存放的是整张表的行记录数据。</span><br><span class="line">聚集索引，适合基于主键的排序查找和范围查找</span><br><span class="line">2. 辅助索引：</span><br><span class="line">辅助索引的叶子节点不存储数据，而是存储聚集索引的主键值（因此主键不宜是占太大的空间的字段）。</span><br><span class="line">当通过辅助索引查找数据时，需要先在辅助索引B+树找到对应的聚集索引的主键值，再到聚集索引B+树查找指定主键值所对应的数据</span><br><span class="line">3. 建立索引的原则：</span><br><span class="line">选择取值重复度低（区分度高）的字段建立索引，比如用户名适合建立索引，性别就不适合建立索引</span><br><span class="line">不要重复创建索引</span><br><span class="line">尽量扩展已有索引，而不是添加新的多余的索引</span><br><span class="line">4. 只select 需要的字段（可能会用到覆盖索引，只需要从辅助索引检索即可查到所需数据，更快），不要select *</span><br><span class="line">5. 联合索引依照最左匹配的顺序来检索B+树，直到遇到范围查询（&gt; &lt; between like）停止匹配，所以经常进行范围查询的字段在联合索引中要放在最后。比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</span><br><span class="line">6. 使用explain 查看执行计划，找出扫描行很多（rows）的语句，修改sql语句使得扫描行尽量少即可</span><br></pre></td></tr></table></figure>
<p>explain 查看select执行计划：</p>
<p>±—±-----------------±--------±-------------±--------±-------------------±------±-----------±-----±-------±---------±-----------+<br>
| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra  |</p>
<p>±—±-----------------±--------±--------------±-------±--------------------±------±-----------±-----±-------±---------±----------+</p>
<blockquote>
<p>id: 查询序号</p>
<p><strong>id相同</strong>：执行顺序由上至下</p>
<p><strong>id不同</strong>：如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</p>
<p><strong>id相同又不同（两种情况同时存在）</strong>：id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行</p>
</blockquote>
<blockquote>
<p>select_type：查询类型</p>
<p><strong>SIMPLE</strong>：简单的select查询，查询中不包含子查询或者union</p>
<p><strong>PRIMARY</strong>：查询中包含任何复杂的子部分，最外层查询则被标记为primary</p>
<p><strong>SUBQUERY</strong>：在select 或 where列表中包含了子查询</p>
<p><strong>DERIVED</strong>：在from列表中包含的子查询被标记为derived（衍生），mysql或递归执行这些子查询，把结果放在临时表里</p>
</blockquote>
<blockquote>
<p>table：查询的数据表，当从衍生表中查数据时会显示<code>&lt;derivedx&gt;</code>， <code>x</code> 表示对应的执行计划<code>id</code></p>
</blockquote>
<blockquote>
<p>partitions：表分区，表创建的时候可以指定通过那个列进行表分区</p>
</blockquote>
<blockquote>
<p>type：访问类型，性能由好到坏依次是：</p>
<p><strong>system</strong> &gt; <strong>const</strong> &gt; <strong>eq_ref</strong> &gt; <strong>ref</strong> &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; <strong>range</strong> &gt; <strong>index</strong> &gt; <strong>ALL</strong></p>
<p><strong>system</strong>：表只有一行记录</p>
<p><strong>const</strong>：表示通过索引一次就找到了，且只有一条匹配记录；const用于比较primary key 或者 unique索引</p>
<p><strong>eq_ref</strong>：唯一性索引或主键扫描</p>
<p><strong>ref</strong>：非唯一性索引扫描，返回匹配某个单独值的所有行</p>
<p><strong>range</strong>：只检索给定范围的行，使用一个索引来选择行</p>
<p><strong>index</strong>：Full Index Scan，遍历索引</p>
<p><strong>ALL</strong>：Full Table Scan，遍历全表</p>
</blockquote>
<blockquote>
<p>possible_keys：查询涉及到的字段上存在索引，则该索引将被列出，但不一定被查询实际使用</p>
</blockquote>
<blockquote>
<p>key：实际使用的索引，如果为NULL，则没有使用索引</p>
</blockquote>
<blockquote>
<p>key_len：查询中使用到的索引的最大可能长度</p>
</blockquote>
<blockquote>
<p>ref：显示使用到的索引字段或常量查询（const）</p>
</blockquote>
<blockquote>
<p>rows：估算找到所需的记录所需要读取的行数</p>
</blockquote>
<blockquote>
<p>extra：额外信息</p>
<p><strong>Using filesort</strong> ：使用非索引列进行排序时出现，非常耗性能</p>
<p><strong>Using temporary</strong>： 使用临时表保存中间结果，常见于order by 和 group by 、join子查询</p>
<p><strong>Using index</strong>：使用了覆盖索引，避免了访问聚集索引数据行，效率高</p>
<p><strong>Using where</strong>：使用了where子句来过滤结果集</p>
</blockquote>
<h3 id="事务查询">事务查询</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show full processlist;</span><br><span class="line">mysql&gt; select * from information_schema.innodb_trx\G;</span><br><span class="line">mysql&gt; select * from information_schema.innodb_locks\G;</span><br><span class="line">mysql&gt; select * from information_schema.innodb_lock_waits\G;</span><br></pre></td></tr></table></figure>
<p>InnoDB在Repeatable Read事务隔离级别下，使用<strong>快照读</strong>，快照读不会占用和等待表锁</p>
<p>应该显示的使用事务，不要使用autocommit</p>
<h3 id="数据库更新丢失问题">数据库更新丢失问题</h3>
<p>并发事务中进行查询并更新可能会导致更新丢失</p>
<p>例如：mysql 事务级别Repeatable Read下：</p>
<p>SET AUTOCOMMIT=0;</p>
<p>CREATE TABLE <code>bank</code> (<br>
<code>id</code> int(10) NOT NULL AUTO_INCREMENT,<br>
<code>money</code> int(10) NOT NULL,<br>
PRIMARY KEY (<code>id</code>)<br>
);</p>
<p>INSERT INTO <code>bank</code> VALUES (1, 900);</p>
<table>
<thead>
<tr>
<th style="text-align:center">事务1（存100元）</th>
<th style="text-align:center">事务2（取100元）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">begin;</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">begin;</td>
</tr>
<tr>
<td style="text-align:center">select * from bank where id=1;（900）</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">select * from bank where id=1; （900）</td>
</tr>
<tr>
<td style="text-align:center">update bank set money=1000 where id=1;</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">update bank set money=800 where id=1;（阻塞直到事务1commit）</td>
</tr>
<tr>
<td style="text-align:center">commit;</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">commit; (事务1的更新被覆盖)</td>
</tr>
</tbody>
</table>
<p>解决办法1：悲观锁（select for update）</p>
<table>
<thead>
<tr>
<th style="text-align:center">事务1（存100元）</th>
<th style="text-align:center">事务2（取100元）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">begin;</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">begin;</td>
</tr>
<tr>
<td style="text-align:center">select * from bank where id=1 for update;</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">select * from bank where id=1 for update;（阻塞直到事务1commit）（1000）</td>
</tr>
<tr>
<td style="text-align:center">update bank set money=1000 where id=1;</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">update bank set money=900 where id=1;（基于1000减去100）</td>
</tr>
<tr>
<td style="text-align:center">commit;</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">commit;</td>
</tr>
</tbody>
</table>
<p>解决办法2：乐观锁-旧值判断</p>
<table>
<thead>
<tr>
<th style="text-align:center">事务1（存100元）</th>
<th style="text-align:center">事务2（取100元）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">begin;</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">begin;</td>
</tr>
<tr>
<td style="text-align:center">select * from bank where id=1;</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">select * from bank where id=1;</td>
</tr>
<tr>
<td style="text-align:center">update bank set money=1000 where id=1 and money=900;</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">update bank set money=800 where id=1 and money=900;（阻塞直到事务1commit，但是此条更新会失败）</td>
</tr>
<tr>
<td style="text-align:center">commit;</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">commit;</td>
</tr>
</tbody>
</table>
<p>解决办法3：乐观锁-表上增加版本字段</p>
<p>CREATE TABLE <code>bank</code> (<br>
<code>id</code> int(10) NOT NULL AUTO_INCREMENT,<br>
<code>money</code> int(10) NOT NULL,<br>
<code>timeStamp</code> int(10) DEFAULT NULL,<br>
PRIMARY KEY (<code>id</code>)<br>
);</p>
<p>INSERT INTO <code>bank</code> VALUES (1, 900, 1571129028);</p>
<table>
<thead>
<tr>
<th style="text-align:center">事务1（存100元）</th>
<th style="text-align:center">事务2（取100元）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">begin;</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">begin;</td>
</tr>
<tr>
<td style="text-align:center">select * from bank where id=1;</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">select * from bank where id=1;</td>
</tr>
<tr>
<td style="text-align:center">update bank set money=1000, timeStamp=1571129243 where id=1 and timeStamp=1571129028;</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">update bank set money=800, timeStamp=1571129246 where id=1 and timeStamp=1571129028;（阻塞直到事务1commit，但是此条更新会失败）</td>
</tr>
<tr>
<td style="text-align:center">commit;</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">commit;</td>
</tr>
</tbody>
</table>
<h3 id="清空表">清空表</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">truncate vs delete</span><br><span class="line">truncate 是ddl操作，不能回滚</span><br><span class="line">delete 是dql操作，可以回滚</span><br></pre></td></tr></table></figure>
<h3 id="慢查询日志配置">慢查询日志配置</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 查看mysql配置文件</span><br><span class="line">mysql --help | grep my.cnf</span><br><span class="line">/etc/my.cnf /etc/mysql/my.cnf /usr/etc/my.cnf ~/.my.cnf</span><br><span class="line"></span><br><span class="line">2. 修改配置文件：vim /etc/my.cnf</span><br><span class="line">slow_query_log=ON</span><br><span class="line">slow_query_log_file=/var/log/slowmysql.log</span><br><span class="line">long_query_time=10</span><br></pre></td></tr></table></figure>
<h3 id="分库分表">分库分表</h3>
<p>分库database：<strong>分库的目的是降低单台服务器负载，切分原则是根据业务紧密程度拆分，缺点是跨数据库无法联表查询</strong></p>
<p>分表table：<strong>当单表数据量超大的时候，B-Tree索引就无法起作用了。除非是覆盖索引查询，否则数据库服务器需要根据索引扫描的结果回表（回主键索引查询叶子节点行记录），查询所有符合条件的记录，如果数据量巨大，这将产生大量随机I/O，随之，数据库的响应时间将大到不可接受的程度。另外，索引维护（磁盘空间、I/O操作）的代价也非常高</strong></p>
<p>分表分为：垂直分表和水平分表</p>
<p>垂直分表：就是表的字段太多，将字段拆分到不同的表中。</p>
<p>水平分表：每个表的字段一样，存储的记录不一样，可以根据业务逻辑进行拆分（user_id，地区，时间，hash等）</p>
<p>水平分表后的问题：</p>
<p>​	怎么设置全局唯一主键（现成方案：snowflake等）</p>
<p>​	怎么保证数据均匀存储，没有热点问题（根据业务逻辑来）</p>
<p>​	怎么方便扩容和缩容（一致性hash）</p>
<h3 id="分区">分区</h3>
<p>分表存在的问题是需要服务端修改，引入中间件来屏蔽分库分表带来的差异</p>
<p>分区相当于mysql层的分表，对服务端是透明的，服务端不需要做任何修改</p>
<p>而且分区的扩容和缩容很容易，直接增加分区，删除分区即可，对数据完整性没影响</p>
<p>所以不存在单机负载问题的情况下，可以用分区来代替分表，简化服务端的更改</p>
<p>参考<a href="http://haitian299.github.io/2016/05/26/mysql-partitioning/" target="_blank" rel="noopener">MySQL分区与传统的分库分表</a></p>
<h3 id="mysql-repication">mysql repication</h3>
<p>主从复制备份，读写分离</p>
<h3 id="mysql-fabric">mysql fabric</h3>
<p>在replication的基础上，提供故障检测和自动Failover、请求路由和分片（sharding）功能</p>
<h3 id="mysql-cluster">mysql cluster</h3>
<p>面向大规模数据的存储解决方案，Cluster的架构思想与Hadoop非常类似，它设计的前提是“认为每个Node都是易于出错的”、集群规模巨大、多租户，所以它提供了数据备份机制、自动迁移、自动Failover等特性，来保证可用性、健壮性。它的核心特性为：数据集并不是存储某个特定的MySQL实例上，而是被分布在多个Data Nodes中，即一个table的数据可能被分散在多个物理节点上，任何数据都会在多个Data Nodes上冗余备份。任何一个数据变更操作，都将在一组Data Nodes上同步以保证数据的一致性。</p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>maven项目部署实践</title>
    <url>/article/maven%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p>使用maven构建spring boot项目，且使用maven插件打包不包含依赖的瘦身jar包</p>
<h2 id="标准pom">标准pom</h2>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--默认打包类型为jar--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>server-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Spring Boot 父项目--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0.M5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--打包不包含依赖的thin jar包，并指定启动类、classpath，并指定不打包资源--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.Application<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">addClasspath</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addClasspath</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">classpathPrefix</span>&gt;</span>lib/<span class="tag">&lt;/<span class="name">classpathPrefix</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--不打包资源文件，copy-resource插件会拷贝到相应的目录去--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>bin/*<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>config/*<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--不编译test类--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">skip</span>&gt;</span>true<span class="tag">&lt;/<span class="name">skip</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--不执行单元测试--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">skip</span>&gt;</span>true<span class="tag">&lt;/<span class="name">skip</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--拷贝依赖 copy-dependencies --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-dependency-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>copy-dependencies<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>copy-dependencies<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;project.basedir&#125;/release/lib<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">overWriteReleases</span>&gt;</span>false<span class="tag">&lt;/<span class="name">overWriteReleases</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">overWriteSnapshots</span>&gt;</span>false<span class="tag">&lt;/<span class="name">overWriteSnapshots</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">overWriteIfNewer</span>&gt;</span>true<span class="tag">&lt;/<span class="name">overWriteIfNewer</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--拷贝资源文件 copy-resources --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resources-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>copy-resources<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>copy-resources<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                                        <span class="comment">&lt;!--拷贝脚本和配置文件--&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">include</span>&gt;</span>bin/*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">include</span>&gt;</span>config/*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.basedir&#125;/target<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                                        <span class="comment">&lt;!--拷贝thin jar包--&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">include</span>&gt;</span>*.jar<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.basedir&#125;<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                                        <span class="comment">&lt;!--拷贝其他配置文件--&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">include</span>&gt;</span>others.conf<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;project.basedir&#125;/release<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resources-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--当资源文件使用$&#123;&#125; 或 @@ 引用pom里的变量，执行替换--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">delimiters</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">delimiter</span>&gt;</span>$&#123;*&#125;<span class="tag">&lt;/<span class="name">delimiter</span>&gt;</span><span class="comment">&lt;!-- to keep the default behavior --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">delimiter</span>&gt;</span>@<span class="tag">&lt;/<span class="name">delimiter</span>&gt;</span><span class="comment">&lt;!-- to add Ant-like tokens style --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">delimiters</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">useDefaultDelimiters</span>&gt;</span>true<span class="tag">&lt;/<span class="name">useDefaultDelimiters</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">nonFilteredFileExtensions</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">nonFilteredFileExtension</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">nonFilteredFileExtension</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">nonFilteredFileExtension</span>&gt;</span>bat<span class="tag">&lt;/<span class="name">nonFilteredFileExtension</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">nonFilteredFileExtension</span>&gt;</span>bytes<span class="tag">&lt;/<span class="name">nonFilteredFileExtension</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">nonFilteredFileExtensions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--执行clean的时候删除logs目录--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-clean-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">filesets</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">fileset</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>logs<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">fileset</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">filesets</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--当资源文件使用$&#123;&#125; 或 @@ 引用pom里的变量，执行替换--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">testResources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">testResource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/test/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--当资源文件使用$&#123;&#125; 或 @@ 引用pom里的变量，执行替换--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">testResource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">testResources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>develop-qj<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activation</span>&gt;</span><span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">properties</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>local<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activation</span>&gt;</span><span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">properties</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>test<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activation</span>&gt;</span><span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">properties</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>product<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activation</span>&gt;</span><span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">properties</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--指定项目依赖jar包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--统一管理依赖的版本--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!--指定下载jar包的远程仓库--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>spring-milestones<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repo.spring.io/milestone<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>spring-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.spring.io/libs-release<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--指定下载插件的远程仓库--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>spring-milestones<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repo.spring.io/milestone<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>spring-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.spring.io/libs-release<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="maven打包">maven打包</h2>
<p>执行 mvn clean package -Pprofile</p>
<p>依次执行：</p>
<p>maven-clean-plugin:3.0.0:clean</p>
<p>删除target目录和本地logs目录</p>
<p>maven-resources-plugin:3.0.2:resources</p>
<p>拷贝src/main/resources下的资源文件到target/classes目录下</p>
<p>maven-compiler-plugin:3.7.0:compile</p>
<p>编译src/main/java 类文件到target/classes目录下</p>
<p>maven-jar-plugin:3.1.0:jar</p>
<p>构建thin jar包到target目录下</p>
<p>maven-dependency-plugin:3.0.1:copy-dependencies</p>
<p>拷贝依赖jar包到release/lib目录下</p>
<p>maven-resources-plugin:3.0.2:copy-resources</p>
<p>拷贝自定义资源文件到release目录下</p>
<p>打包后的项目和相关资源文件依赖jar包都放在release目录下：</p>
<p><img src="https://qiaojiande-1259482780.cos.ap-chengdu.myqcloud.com/201908/maven-project-release-dir.jpg" alt=""></p>
<h2 id="发布">发布</h2>
<p>rysnc脚本：其中test_env是在~/.ssh/config下定义的机器别名</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">touch ./release/application.pid</span><br><span class="line">chmod a+x ./release/bin/*.sh</span><br><span class="line">release_dir=/home/server-demo/release/</span><br><span class="line">zip -r server-demo-release.zip ./release/</span><br><span class="line">rsync -zvrP --delete --rsync-path=<span class="string">"mkdir -p <span class="variable">$release_dir</span> &amp;&amp; rm -rf <span class="variable">$release_dir</span>/*.jar &amp;&amp; rsync"</span>  ./server-demo-release.zip test_env:<span class="variable">$release_dir</span></span><br></pre></td></tr></table></figure>
<p>此时，release目录包含了要运行的java程序的所有组件，将此目录压缩成zip包，使用rsync脚本上传到相应的服务器，启动即可。</p>
<p>根据需求可将release目录下的文件分开上传，例如lib目录下的依赖jar包没有更新就不需要每次重复校验上传了。</p>
]]></content>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>通过gRPC添加删除v2ray用户</title>
    <url>/article/%E9%80%9A%E8%BF%87gRPC%E6%B7%BB%E5%8A%A0%E5%88%A0%E9%99%A4v2ray%E7%94%A8%E6%88%B7/</url>
    <content><![CDATA[<h3 id="什么是grpc">什么是gRPC？</h3>
<p>gRPC是谷歌开源的一个远程方法调用（Remote Process Call）框架，gRPC基于CS模型，使得客户端可以像调用本地方法一样调用远程服务端的方法，使得您能够更容易地创建分布式应用和服务。</p>
<p>gRPC使用ProtoBuffers作为数据序列化传输工具，gRPC-java使用netty作为网络通信基础设施。</p>
<p><img src="https://qiaojiande-1259482780.cos.ap-chengdu.myqcloud.com/201908/20190828141336.png" alt=""></p>
<h3 id="v2ray开放基于grpc的api接口">V2Ray开放基于gRPC的API接口</h3>
<h4 id="handlerservice">HandlerService</h4>
<p>一些对于入站出站代理进行修改的 API，可用的功能如下：</p>
<ul>
<li>添加一个新的入站代理；</li>
<li>添加一个新的出站代理；</li>
<li>删除一个现有的入站代理；</li>
<li>删除一个现有的出站代理；</li>
<li>在一个入站代理中添加一个用户（仅支持 VMess）；</li>
<li>在一个入站代理中删除一个用户（仅支持 VMess）；</li>
</ul>
<h4 id="loggerservice">LoggerService</h4>
<p>支持对内置 Logger 的重启，可配合 logrotate 进行一些对日志文件的操作。</p>
<h4 id="statsservice">StatsService</h4>
<p>内置的数据统计服务</p>
<h3 id="springboot-项目通过grpc向v2ray服务添加用户-删除用户">SpringBoot 项目通过gRPC向V2Ray服务添加用户、删除用户</h3>
<h4 id="v2ray服务configjson配置开放api接口">v2ray服务config.json配置开放api接口</h4>
<ul>
<li>从github拉去v2ray代码：git clone <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:v2ray/v2ray-core.git</li>
<li>编译v2ray：cd v2ray-core/main; go build -ldflags ‘-w -s’ -o v2ray</li>
<li>编译v2ctl：cd v2ray-core/infra/control/main; go build -ldflags ‘-w -s’ -o v2ctl</li>
<li>配置config.json，开放API接口</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"api"</span>: &#123;</span><br><span class="line">        <span class="attr">"services"</span>: [</span><br><span class="line">            <span class="string">"HandlerService"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"tag"</span>: <span class="string">"api"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"inbound"</span>: &#123;</span><br><span class="line">        <span class="attr">"port"</span>: <span class="number">10086</span>,</span><br><span class="line">        <span class="attr">"protocol"</span>: <span class="string">"vmess"</span>,</span><br><span class="line">        <span class="attr">"settings"</span>: &#123;</span><br><span class="line">            <span class="attr">"clients"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"alterId"</span>: <span class="number">32</span>,</span><br><span class="line">                    <span class="attr">"id"</span>: <span class="string">"fcecbd2b-3a34-4201-bd3d-7c67d89c26ba"</span>,</span><br><span class="line">                    <span class="attr">"level"</span>: <span class="number">0</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"streamSettings"</span>: &#123;</span><br><span class="line">            <span class="attr">"network"</span>: <span class="string">"tcp"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"tag"</span>: <span class="string">"proxy"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"inboundDetour"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"listen"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">            <span class="attr">"port"</span>: <span class="number">10085</span>,</span><br><span class="line">            <span class="attr">"protocol"</span>: <span class="string">"dokodemo-door"</span>,</span><br><span class="line">            <span class="attr">"settings"</span>: &#123;</span><br><span class="line">                <span class="attr">"address"</span>: <span class="string">"127.0.0.1"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"tag"</span>: <span class="string">"api"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"log"</span>: &#123;</span><br><span class="line">        <span class="attr">"loglevel"</span>: <span class="string">"debug"</span>,</span><br><span class="line">		<span class="attr">"access"</span> : <span class="string">"~/go/src/v2ray-core/log_access.log"</span>,</span><br><span class="line">		<span class="attr">"error"</span> : <span class="string">"~/go/src/v2ray-core/log_error.log"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"outbound"</span>: &#123;</span><br><span class="line">        <span class="attr">"protocol"</span>: <span class="string">"freedom"</span>,</span><br><span class="line">        <span class="attr">"settings"</span>: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"routing"</span>: &#123;</span><br><span class="line">        <span class="attr">"settings"</span>: &#123;</span><br><span class="line">            <span class="attr">"rules"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"inboundTag"</span>: [</span><br><span class="line">                        <span class="string">"api"</span></span><br><span class="line">                    ],</span><br><span class="line">                    <span class="attr">"outboundTag"</span>: <span class="string">"api"</span>,</span><br><span class="line">                    <span class="attr">"type"</span>: <span class="string">"field"</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"strategy"</span>: <span class="string">"rules"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>运行v2ray服务：./v2ray -config config.json</li>
</ul>
<h4 id="springboot项目引入grpc">springboot项目引入gRPC</h4>
<p>参考https://github.com/grpc/grpc-java</p>
<p>pom.xml 引入grpc依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;io.grpc&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;grpc-netty-shaded&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.23.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;io.grpc&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;grpc-protobuf&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.23.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;io.grpc&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;grpc-stub&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.23.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>引入自动生成代码插件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">  &lt;extensions&gt;</span><br><span class="line">    &lt;extension&gt;</span><br><span class="line">      &lt;groupId&gt;kr.motd.maven&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;os-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;1.6.2&lt;/version&gt;</span><br><span class="line">    &lt;/extension&gt;</span><br><span class="line">  &lt;/extensions&gt;</span><br><span class="line">  &lt;plugins&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">      &lt;groupId&gt;org.xolstice.maven.plugins&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;protobuf-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;0.6.1&lt;/version&gt;</span><br><span class="line">      &lt;configuration&gt;</span><br><span class="line">        &lt;protocArtifact&gt;com.google.protobuf:protoc:3.9.0:exe:$&#123;os.detected.classifier&#125;&lt;/protocArtifact&gt;</span><br><span class="line">        &lt;pluginId&gt;grpc-java&lt;/pluginId&gt;</span><br><span class="line">        &lt;pluginArtifact&gt;io.grpc:protoc-gen-grpc-java:1.23.0:exe:$&#123;os.detected.classifier&#125;&lt;/pluginArtifact&gt;</span><br><span class="line">      &lt;/configuration&gt;</span><br><span class="line">      &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">          &lt;goals&gt;</span><br><span class="line">            &lt;goal&gt;compile&lt;/goal&gt;</span><br><span class="line">            &lt;goal&gt;compile-custom&lt;/goal&gt;</span><br><span class="line">          &lt;/goals&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">      &lt;/executions&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">  &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>
<p>自动生成代码插件默认根据src/main/proto目录下的proto文件来生成java代码，放在target/generated-sources目录下</p>
<p><img src="https://qiaojiande-1259482780.cos.ap-chengdu.myqcloud.com/201908/grpc-2.jpg" alt=""></p>
<h4 id="编写grpc-client-代码">编写gRPC client 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">V2RayCoreService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Logger log = LoggerFactory.getLogger ( V2RayCoreService.class );</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span> ( <span class="string">"$&#123;v2ray.core.host&#125;"</span> )</span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="meta">@Value</span> ( <span class="string">"$&#123;v2ray.core.port&#125;"</span> )</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同步调用stub</span></span><br><span class="line">    <span class="keyword">private</span> HandlerServiceGrpc.HandlerServiceBlockingStub  blockingStub;</span><br><span class="line">    <span class="comment">//异步调用stub</span></span><br><span class="line">    <span class="keyword">private</span> HandlerServiceGrpc.HandlerServiceStub asyncStub;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ManagedChannel <span class="title">channelBuild</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> NettyChannelBuilder.forAddress ( host, port)</span><br><span class="line">                .negotiationType ( NegotiationType.PLAINTEXT ).build ();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> HandlerServiceGrpc.<span class="function">HandlerServiceBlockingStub <span class="title">constructBlockingStub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (blockingStub == <span class="keyword">null</span>) &#123;</span><br><span class="line">            blockingStub = HandlerServiceGrpc.newBlockingStub(channelBuild ( host, port ));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> blockingStub;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> HandlerServiceGrpc.<span class="function">HandlerServiceStub <span class="title">constructAsyncStub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (asyncStub == <span class="keyword">null</span>) &#123;</span><br><span class="line">            asyncStub = HandlerServiceGrpc.newStub ( channelBuild ( host, port ) );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> asyncStub;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>: 在一个入站代理中添加一个用户</span></span><br><span class="line"><span class="comment">     *      v2RayCoreService.addUser ("proxy",</span></span><br><span class="line"><span class="comment">     *                                      0,</span></span><br><span class="line"><span class="comment">     *                       "test@gmail.com",</span></span><br><span class="line"><span class="comment">     * "4c4893c5-7c8f-03a0-0f86-afc800f2897a",</span></span><br><span class="line"><span class="comment">     *                                     5);</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Command.<span class="function">AlterInboundRequest <span class="title">addUser</span><span class="params">(String inBoundTag, <span class="keyword">int</span> userLevel, String userEmail,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               String uuid, <span class="keyword">int</span> alterId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Headers.SecurityConfig securityConfig = Headers.SecurityConfig.newBuilder()</span><br><span class="line">                .setType ( Headers.SecurityType.AUTO )</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        AccountOuterClass.Account account = AccountOuterClass.Account.newBuilder()</span><br><span class="line">                .setId ( uuid )</span><br><span class="line">                .setAlterId ( alterId  )</span><br><span class="line">                .setSecuritySettings ( securityConfig )</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        UserOuterClass.User user = UserOuterClass.User.newBuilder()</span><br><span class="line">                .setLevel ( userLevel )</span><br><span class="line">                .setEmail ( userEmail )</span><br><span class="line">                .setAccount ( toTypedMessage ( account, <span class="string">"v2ray.core.proxy.vmess.Account"</span> ) )</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        Command.AddUserOperation addUserOperation = Command.AddUserOperation.newBuilder()</span><br><span class="line">                .setUser ( user )</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        TypedMessageOuterClass.TypedMessage operation = toTypedMessage ( addUserOperation,  <span class="string">"v2ray.core.app.proxyman.command.AddUserOperation"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Command.AlterInboundRequest.newBuilder()</span><br><span class="line">                .setTag ( inBoundTag )</span><br><span class="line">                .setOperation ( operation )</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>: 在一个入站代理中删除一个用户</span></span><br><span class="line"><span class="comment">     * v2RayCoreService.removeUser ( "proxy",</span></span><br><span class="line"><span class="comment">     *                      "test@gmail.com")</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Command.<span class="function">AlterInboundRequest <span class="title">removeUser</span><span class="params">(String inBoundTag, String email)</span> </span>&#123;</span><br><span class="line">        Command.RemoveUserOperation removeUserOperation = Command.RemoveUserOperation.newBuilder()</span><br><span class="line">                .setEmail ( email )</span><br><span class="line">                .build();</span><br><span class="line">        TypedMessageOuterClass.TypedMessage operation = toTypedMessage ( removeUserOperation, <span class="string">"v2ray.core.app.proxyman.command.RemoveUserOperation"</span> );</span><br><span class="line">        <span class="keyword">return</span> Command.AlterInboundRequest.newBuilder()</span><br><span class="line">                .setTag ( inBoundTag )</span><br><span class="line">                .setOperation ( operation )</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步接口</span></span><br><span class="line"><span class="comment">     * 使用示例：添加用户 </span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *            v2RayCoreService.alterInboudBlocking (</span></span><br><span class="line"><span class="comment">     *              v2RayCoreService.addUser ("proxy",</span></span><br><span class="line"><span class="comment">     *                      0,</span></span><br><span class="line"><span class="comment">     *                      "test@gmail.com",</span></span><br><span class="line"><span class="comment">     *                      "4c4893c5-7c8f-03a0-0f86-afc800f2897a",</span></span><br><span class="line"><span class="comment">     *                      5)</span></span><br><span class="line"><span class="comment">     *      );</span></span><br><span class="line"><span class="comment">     * 使用示例：删除用户</span></span><br><span class="line"><span class="comment">     *           v2RayCoreService.alterInboudBlocking (</span></span><br><span class="line"><span class="comment">     *              v2RayCoreService.removeUser ( "proxy",</span></span><br><span class="line"><span class="comment">     *                      "test@gmail.com")</span></span><br><span class="line"><span class="comment">     *      );</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">alterInboudBlocking</span><span class="params">(Command.AlterInboundRequest alterInboundRequest)</span> </span>&#123;</span><br><span class="line">        constructBlockingStub ().alterInbound ( alterInboundRequest );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异步接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">alterInboundAsync</span><span class="params">(Command.AlterInboundRequest alterInboundRequest)</span> </span>&#123;</span><br><span class="line">        constructAsyncStub ().alterInbound ( alterInboundRequest, <span class="keyword">new</span> StreamObserver&lt;Command.AlterInboundResponse&gt; () &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Command.AlterInboundResponse alterInboundResponse)</span> </span>&#123;</span><br><span class="line">                log.info ( <span class="string">"async alter inbound onNext response &#123;&#125;"</span>, alterInboundResponse );</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">                log.error ( <span class="string">"async alter inbound error &#123;&#125;"</span>, throwable );</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                log.info ( <span class="string">"async alter inbound completed"</span> );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TypedMessageOuterClass.<span class="function">TypedMessage <span class="title">toTypedMessage</span><span class="params">(Message message, String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (message == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> TypedMessageOuterClass.TypedMessage.newBuilder()</span><br><span class="line">                .setType ( type )</span><br><span class="line">                .setValue ( message.toByteString () )</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>设计模式-代理模式</title>
    <url>/article/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="定义">定义</h3>
<p><strong>代理模式</strong>是一种结构型设计模式， 让你能够提供对象的替代品。 代理控制着对原对象的访问， 并允许在将请求提交给对象前后进行一些处理。</p>
<h3 id="静态代理">静态代理</h3>
<p>这种代理方式需要代理对象和目标对象实现一样的接口。优点：可以在不修改目标对象的前提下扩展目标对象的功能。缺点：扩展被代理类功能时会产生过多的代理类，如果目标接口修改，所有类包括代理类都要修改。</p>
<p>静态代理的两种实现方式：1、继承，2、组合</p>
<p>先定义目标类和接口如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">implements</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(Bird.class);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info ( <span class="string">"Bird flying"</span> );</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">           Thread.sleep ( <span class="keyword">new</span> Random ( ).nextInt (<span class="number">100</span>) );</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace ();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="继承">继承</h4>
<p>通过继承的方式来新建两个代理类统计时间和记录Log，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BirdFlyTime</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger ( BirdFlyTime.class );</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis ();</span><br><span class="line">        <span class="keyword">super</span>.fly ();</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis ();</span><br><span class="line">        logger.info ( <span class="string">"Bird flying time: &#123;&#125;"</span>, end - start );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BirdLog</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger ( BirdLog.class );</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info ( <span class="string">"Bird fly start..."</span> );</span><br><span class="line">        <span class="keyword">super</span>.fly ();</span><br><span class="line">        logger.info ( <span class="string">"Bird fly end..."</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用继承代理：可知使用继承实现的静态代理，不能同时使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Bird bird = <span class="keyword">new</span> Bird ();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用继承实现的静态代理，不能同时使用</span></span><br><span class="line">    BirdLog birdLog = <span class="keyword">new</span> BirdLog ();</span><br><span class="line">    birdLog.fly ();</span><br><span class="line">    </span><br><span class="line">    BirdFlyTime birdFlyTime = <span class="keyword">new</span> BirdFlyTime ();</span><br><span class="line">    birdFlyTime.fly ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="组合">组合</h4>
<p>通过组合的方式来新建两个代理类统计时间和记录Log，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BirdFlyTimeProxy</span> <span class="keyword">implements</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger ( BirdFlyTimeProxy.class );</span><br><span class="line">    <span class="keyword">private</span> Flyable flyable;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BirdFlyTimeProxy</span><span class="params">(Flyable flyable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flyable = flyable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">long</span> start = System.currentTimeMillis ();</span><br><span class="line">       logger.info ( <span class="string">"Bird flying start time: &#123;&#125;"</span>, start );</span><br><span class="line">       flyable.fly ();</span><br><span class="line">       <span class="keyword">long</span> end = System.currentTimeMillis ();</span><br><span class="line">       logger.info ( <span class="string">"Bird flying end time: &#123;&#125;"</span>, end );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BirdLogProxy</span> <span class="keyword">implements</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger ( BirdLogProxy.class );</span><br><span class="line">    <span class="keyword">private</span> Flyable flyable;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BirdLogProxy</span><span class="params">(Flyable flyable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flyable = flyable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info ( <span class="string">"Bird fly start..."</span> );</span><br><span class="line">        flyable.fly ();</span><br><span class="line">        logger.info ( <span class="string">"Bird fly end..."</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用组合代理：可知使用组合实现的静态代理可以同时使用并灵活调换代理的执行顺序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Bird bird = <span class="keyword">new</span> Bird ();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用组合实现的静态代理可以同时使用并灵活调换代理的执行顺序</span></span><br><span class="line">    BirdLogProxy birdLogProxy1 = <span class="keyword">new</span> BirdLogProxy ( bird );</span><br><span class="line">    BirdFlyTimeProxy birdFlyTimeProxy1 = <span class="keyword">new</span> BirdFlyTimeProxy ( birdLogProxy1 );</span><br><span class="line">    birdFlyTimeProxy1.fly ();</span><br><span class="line"></span><br><span class="line">    BirdFlyTimeProxy birdFlyTimeProxy2 = <span class="keyword">new</span> BirdFlyTimeProxy ( bird );</span><br><span class="line">    BirdLogProxy birdLogProxy2 = <span class="keyword">new</span> BirdLogProxy ( birdFlyTimeProxy2 );</span><br><span class="line">    birdLogProxy2.fly ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="动态代理">动态代理</h3>
<p>相对于静态代理需要手动书写代理类然后编译生成class文件载入JVM运行，动态代理是在JVM运行起来以后在内存中动态的创建代理类class文件（字节流）并载入JVM执行。</p>
<p>动态代理又分为JDK动态代理和CGLIB动态代理。</p>
<h4 id="jdk动态代理">JDK动态代理</h4>
<p>要使用JDK动态代理有一个前提，要求被代理的目标类必须实现接口。JDK动态代理可以看作组合型静态代理的扩展，它封装了具体的被代理目标类，提供一个统一的接口InvocationHandler，让代理类实现这个接口即可，实现了对所有不同目标类的代理功能。</p>
<p>还是以上面Flyable接口+Bird类举例使用JDK代理。</p>
<p>首先代理类需要实现InvocationHandler接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BirdLogProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger ( BirdLogProxy.class );</span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BirdLogProxy</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.object = object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        logger.info ( <span class="string">"Bird fly start..."</span> );</span><br><span class="line">        method.invoke ( object, args);</span><br><span class="line">        logger.info ( <span class="string">"Bird fly end..."</span> );</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BirdFlyTimeProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger ( BirdFlyTimeProxy.class );</span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BirdFlyTimeProxy</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.object = object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis ();</span><br><span class="line">        logger.info ( <span class="string">"Bird flying start time: &#123;&#125;"</span>, start );</span><br><span class="line">        method.invoke ( object, args );</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis ();</span><br><span class="line">        logger.info ( <span class="string">"Bird flying end time: &#123;&#125;"</span>, end );</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后根具体的目标类绑定，调用Proxy.newProxyInstance即可生成代理类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKProxyUsage</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Bird bird = <span class="keyword">new</span> Bird ();</span><br><span class="line">        </span><br><span class="line">        BirdLogProxy birdLogProxy = <span class="keyword">new</span> BirdLogProxy ( bird );</span><br><span class="line">        Flyable flyable = (Flyable) Proxy.newProxyInstance ( bird.getClass ().getClassLoader (), bird.getClass ().getInterfaces (), birdLogProxy );</span><br><span class="line">        flyable.fly ();</span><br><span class="line">        </span><br><span class="line">        BirdFlyTimeProxy birdFlyTimeProxy = <span class="keyword">new</span> BirdFlyTimeProxy ( bird );</span><br><span class="line">        flyable = (Flyable) Proxy.newProxyInstance ( bird.getClass ().getClassLoader (), bird.getClass ().getInterfaces (), birdFlyTimeProxy );</span><br><span class="line">        flyable.fly ();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="cglib动态代理">CGLIB动态代理</h4>
<p>CGLIB是一个第三方代码生成类库，它的底层是通过使用一个字节码处理框架ASM，来转换字节码并生成新的类。CGLIB动态代理和JDK动态代理的区别是：<strong>CGLIB对被代理的目标类没有必须要实现接口的要求，只要目标类不是final类即可</strong>，由此可见CGLIB是使用继承的方式来实现代理类的。</p>
<p>还是以上面Flyable接口+Bird类举例使用CGLIB代理。</p>
<p>首先代理类需要实现MethodInterceptor接口（此处使用了单例模式），通过getProxy方法即可生成代理类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BirdLogProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger ( BirdLogProxy.class );</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BirdLogProxy cglibProxy = <span class="keyword">new</span> BirdLogProxy ();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">BirdLogProxy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BirdLogProxy <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cglibProxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> (T) Enhancer.create ( clazz, <span class="keyword">this</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        logger.info ( <span class="string">"Bird fly start..."</span> );</span><br><span class="line">        methodProxy.invokeSuper ( o, objects );</span><br><span class="line">        logger.info ( <span class="string">"Bird fly end..."</span> );</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BirdFlyTimeProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger ( BirdFlyTimeProxy.class );</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BirdFlyTimeProxy cglibProxy = <span class="keyword">new</span> BirdFlyTimeProxy ();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">BirdFlyTimeProxy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BirdFlyTimeProxy <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cglibProxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> (T) Enhancer.create ( clazz, <span class="keyword">this</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis ();</span><br><span class="line">        logger.info ( <span class="string">"Bird flying start time: &#123;&#125;"</span>, start );</span><br><span class="line">        methodProxy.invokeSuper ( o, objects );</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis ();</span><br><span class="line">        logger.info ( <span class="string">"Bird flying end time: &#123;&#125;"</span>, end );</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用CGLIB代理如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Bird bird = BirdLogProxy.getInstance ().getProxy ( Bird.class );</span><br><span class="line">    bird.fly ();</span><br><span class="line"></span><br><span class="line">    bird = BirdFlyTimeProxy.getInstance ().getProxy ( Bird.class );</span><br><span class="line">    bird.fly ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-责任链模式</title>
    <url>/article/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>责任链模式是一种行为设计模式， 允许你将请求沿着处理者链进行发送。 收到请求后， 处理链上的每个处理者均可对请求进行处理（修改request，response，return）， 或将其传递给链上的下个处理者。</p>
<p>servlet模块即是使用了责任链模式来对请求进行过滤。</p>
<p>我们模仿servlet的过滤链处理来举例说明：</p>
<p><strong>第一步</strong></p>
<p>首先定义过滤器处理接口：Filter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(Request request, Response response, FilterChain filterChain)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中FilterChain是过滤链接口，过滤链组合所有的过滤器并进行顺序过滤处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FilterChain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(Request request, Response response)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中Request接口代表要处理的请求：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getParameter</span><span class="params">(String var1)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setParameter</span><span class="params">(String key, String value)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中Response接口代表要回复的响应：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Response</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeContent</span><span class="params">(String var1)</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getContent</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后定义一个FilterConfig接口，FilterConfig和Filter是1对1的关系，用于对Filter参数进行封装</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: FilterConfig 管理具体的Filter，为不同的Filter配置不一样的参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-03-02 09:51</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FilterConfig</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getFilterParameter</span><span class="params">(String var1)</span></span>;</span><br><span class="line">    <span class="function">Filter <span class="title">getFilter</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后定义一个Servlet接口，用于过滤处理完成之后的业务处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 过滤链处理完成后交给Servlet进行后续处理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-03-03 09:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">service</span><span class="params">(Request request, Response response)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二步</p>
<p>我们实现两个具体Filter：EnCodingFilter用于对请求编码进行验证，ContentTypeFilter用于对请求内容类型进行验证：</p>
<p>EnCodingFilter：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnCodingFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> FilterConfig filterConfig;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过FilterConfig获取到过滤器参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.filterConfig = filterConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(Request request, Response response, FilterChain filterChain)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. do something</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.filterConfig.getFilterParameter ( <span class="string">"encode"</span> ).equalsIgnoreCase ( request.getParameter ( <span class="string">"encode"</span> ) )) &#123;</span><br><span class="line">            System.out.println ( <span class="string">"ENCODING FILTER CHECKING FAIL"</span> );</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println ( <span class="string">"encode: "</span> + request.getParameter ( <span class="string">"encode"</span> ) + <span class="string">" OK!"</span> );</span><br><span class="line">        response.writeContent ( <span class="string">"ENCODE OK;"</span> );</span><br><span class="line">        <span class="comment">// 2. 向下传递</span></span><br><span class="line">        filterChain.doFilter ( request, response );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ContentTypeFilter：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContentTypeFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> FilterConfig filterConfig;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过FilterConfig获取到过滤器参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.filterConfig = filterConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(Request request, Response response, FilterChain filterChain)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. do something</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.filterConfig.getFilterParameter ( <span class="string">"content-type"</span> ).equalsIgnoreCase ( request.getParameter ( <span class="string">"content-type"</span> ) )) &#123;</span><br><span class="line">            System.out.println ( <span class="string">"CONTENT-TYPE FILTER CHECKING FAIL"</span> );</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println ( <span class="string">"content-type: "</span> + request.getParameter ( <span class="string">"content-type"</span> ) + <span class="string">" OK!"</span> );</span><br><span class="line">        response.writeContent ( <span class="string">"CONTENT-TYPE OK;"</span> );</span><br><span class="line">        <span class="comment">// 2. 向下传递</span></span><br><span class="line">        filterChain.doFilter ( request, response );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>第三步</strong></p>
<p>实现一个FilterChain，保存所有配置的Filter，并进行过滤链的调用处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * FilterChain 有序保存所有的Filter，按顺序调用所有的Filter进行过滤处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppFilterChain</span> <span class="keyword">implements</span> <span class="title">FilterChain</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AppFilterConfig[] filters = <span class="keyword">new</span> AppFilterConfig[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Servlet servlet = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setServlet</span><span class="params">(Servlet servlet)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.servlet = servlet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addFilter</span><span class="params">(AppFilterConfig filterConfig)</span> </span>&#123;</span><br><span class="line">        AppFilterConfig[] newFilters = <span class="keyword">this</span>.filters;</span><br><span class="line">        <span class="keyword">int</span> var3 = newFilters.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.判断filter里是否已经存在</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> var4 = <span class="number">0</span>; var4 &lt; var3; ++var4) &#123;</span><br><span class="line">            AppFilterConfig filter = newFilters[var4];</span><br><span class="line">            <span class="keyword">if</span> (filter == filterConfig) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.判断filter数组是否需要扩容</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.n == <span class="keyword">this</span>.filters.length) &#123;</span><br><span class="line">            newFilters = <span class="keyword">new</span> AppFilterConfig[<span class="keyword">this</span>.n + <span class="number">10</span>];</span><br><span class="line">            System.arraycopy(<span class="keyword">this</span>.filters, <span class="number">0</span>, newFilters, <span class="number">0</span>, <span class="keyword">this</span>.n);</span><br><span class="line">            <span class="keyword">this</span>.filters = newFilters;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.添加filter</span></span><br><span class="line">        <span class="keyword">this</span>.filters[<span class="keyword">this</span>.n++] = filterConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(Request request, Response response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.pos &lt; <span class="keyword">this</span>.n) &#123;</span><br><span class="line">            AppFilterConfig filterConfig = <span class="keyword">this</span>.filters[<span class="keyword">this</span>.pos++];</span><br><span class="line">            Filter filter = filterConfig.getFilter ();</span><br><span class="line">            filter.doFilter(request, response, <span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// filter chain 处理完毕，交给业务处理</span></span><br><span class="line">            <span class="keyword">this</span>.servlet.service ( request, response );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>第四步</strong></p>
<p>实现一个具体的业务Servlet：AppServlet</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppServlet</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(Request request, Response response)</span> </span>&#123;</span><br><span class="line">        System.out.println ( <span class="string">"通过FILTER CHAIN处理，进入业务服处理: Response: "</span> + response.getContent () );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>第五步</strong></p>
<p>提供一个工具类来组装FilterChain</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 组装FilterChain</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span>  <span class="class"><span class="keyword">class</span> <span class="title">AppFilterFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AppFilterChain <span class="title">createFilterChain</span><span class="params">(Request request, Servlet servlet)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 实例化FilterChain</span></span><br><span class="line">        AppFilterChain appFilterChain = <span class="keyword">new</span> AppFilterChain ();</span><br><span class="line">        appFilterChain.setServlet ( servlet );</span><br><span class="line">        <span class="comment">// 2. 添加具体的Filter，此处添加的顺序即表示Filter被处理的顺序</span></span><br><span class="line">        EnCodingFilter enCodingFilter = <span class="keyword">new</span> EnCodingFilter ();</span><br><span class="line">        Map&lt;String, String&gt; enCodingParams = <span class="keyword">new</span> HashMap&lt;&gt; ( );</span><br><span class="line">        enCodingParams.put ( <span class="string">"encode"</span>, <span class="string">"utf-8"</span> );</span><br><span class="line">        AppFilterConfig appFilterConfig = <span class="keyword">new</span> AppFilterConfig ( enCodingFilter, enCodingParams);</span><br><span class="line">        enCodingFilter.init ( appFilterConfig );</span><br><span class="line">        appFilterChain.addFilter ( appFilterConfig );</span><br><span class="line"></span><br><span class="line">        ContentTypeFilter contentTypeFilter = <span class="keyword">new</span> ContentTypeFilter ();</span><br><span class="line">        Map&lt;String, String&gt; contentTypeParams = <span class="keyword">new</span> HashMap&lt;&gt; ( );</span><br><span class="line">        contentTypeParams.put ( <span class="string">"content-type"</span>, <span class="string">"application/json"</span> );</span><br><span class="line">        appFilterConfig = <span class="keyword">new</span> AppFilterConfig ( contentTypeFilter, contentTypeParams );</span><br><span class="line">        contentTypeFilter.init ( appFilterConfig );</span><br><span class="line">        appFilterChain.addFilter ( appFilterConfig );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> appFilterChain;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>第六步</strong></p>
<p>实现一个具体的请求类AppRequest和响应类AppResponse：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppRequest</span> <span class="keyword">implements</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; parameters = <span class="keyword">new</span> HashMap&lt;&gt; ( );</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParameter</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parameters.put ( key, value );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getParameter</span><span class="params">(String var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.parameters.get ( var1 );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppResponse</span> <span class="keyword">implements</span> <span class="title">Response</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line">    <span class="comment">// 此处写到String，打印</span></span><br><span class="line">    <span class="comment">// 实际的HttpServletResponse通过PrintWriter将返回内容写到Socket</span></span><br><span class="line">    <span class="keyword">private</span> StringWriter writer = <span class="keyword">new</span> StringWriter (  );</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeContent</span><span class="params">(String var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.writer.append ( var1 );</span><br><span class="line">        <span class="keyword">this</span>.content = <span class="keyword">this</span>.writer.toString ();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个责任链模式实现完成，最后来使用下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChainUsage</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Request request = <span class="keyword">new</span> AppRequest ();</span><br><span class="line">        request.setParameter ( <span class="string">"encode"</span>, <span class="string">"utf-8"</span> );</span><br><span class="line">        request.setParameter ( <span class="string">"content-type"</span>, <span class="string">"application/json"</span> );</span><br><span class="line">        Servlet servlet = <span class="keyword">new</span> AppServlet ();</span><br><span class="line">        Response response = <span class="keyword">new</span> AppResponse ();</span><br><span class="line">        FilterChain filterChain = AppFilterFactory.createFilterChain ( request,  servlet );</span><br><span class="line">        filterChain.doFilter ( request, response );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>提供和过滤器配置的参数一样，则过滤器处理成功，交给业务处理，输出如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">encode: utf-8 OK!</span><br><span class="line">content-type: application/json OK!</span><br><span class="line">通过FILTER CHAIN处理，进入业务服处理: Response: ENCODE OK;CONTENT-TYPE OK;</span><br></pre></td></tr></table></figure>
<p>修改request.setParameter ( “encode”, “utf-16” );测试，编码过滤器处理不通过直接返回，输出如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ENCODING FILTER CHECKING FAIL</span><br></pre></td></tr></table></figure>
<p>修改request.setParameter ( “content-type”, “multipart/form-data” );测试，内容类型过滤器处理不通过直接返回，输出如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">encode: utf-8 OK!</span><br><span class="line">CONTENT-TYPE FILTER CHECKING FAIL</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-观察者模式</title>
    <url>/article/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>首先了解观察者模式和发布订阅模式的区别：参考 <a href="https://juejin.im/post/5a14e9edf265da4312808d86" target="_blank" rel="noopener">https://juejin.im/post/5a14e9edf265da4312808d86</a></p>
<p>简单说就是，观察者模式中，观察者Observer和被观察者Observable是紧耦合的；而发布订阅模式中，发布者Publisher和订阅者Subscriber是去耦合的，通过第三方Topic或Channel关联。</p>
<p>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够进行相应的反应处理。</p>
<p>JDK自带对观察者模式的实现：提供一个被观察者类Observable和观察者接口Observer，被观察者维护了观察者列表在状态改变时会遍历通知所有观察者（因此被观察者和观察者紧耦合）</p>
<p>Observable：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> Vector&lt;Observer&gt; obs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Construct an Observable with zero Observers. */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Observable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        obs = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> (!obs.contains(o)) &#123;</span><br><span class="line">            obs.addElement(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deleteObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        obs.removeElement(o);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        notifyObservers(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(Object arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * a temporary array buffer, used as a snapshot of the state of</span></span><br><span class="line"><span class="comment">         * current Observers.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Object[] arrLocal;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">/* We don't want the Observer doing callbacks into</span></span><br><span class="line"><span class="comment">             * arbitrary code while holding its own Monitor.</span></span><br><span class="line"><span class="comment">             * The code where we extract each Observable from</span></span><br><span class="line"><span class="comment">             * the Vector and store the state of the Observer</span></span><br><span class="line"><span class="comment">             * needs synchronization, but notifying observers</span></span><br><span class="line"><span class="comment">             * does not (should not).  The worst result of any</span></span><br><span class="line"><span class="comment">             * potential race-condition here is that:</span></span><br><span class="line"><span class="comment">             * 1) a newly-added Observer will miss a</span></span><br><span class="line"><span class="comment">             *   notification in progress</span></span><br><span class="line"><span class="comment">             * 2) a recently unregistered Observer will be</span></span><br><span class="line"><span class="comment">             *   wrongly notified when it doesn't care</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (!changed)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            arrLocal = obs.toArray();</span><br><span class="line">            clearChanged();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arrLocal.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">            ((Observer)arrLocal[i]).update(<span class="keyword">this</span>, arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deleteObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        obs.removeAllElements();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        changed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">clearChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        changed = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">hasChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> changed;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">countObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obs.size();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Observer：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method is called whenever the observed object is changed. An</span></span><br><span class="line"><span class="comment">     * application calls an &lt;tt&gt;Observable&lt;/tt&gt; object's</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;notifyObservers&lt;/code&gt; method to have all the object's</span></span><br><span class="line"><span class="comment">     * observers notified of the change.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   o     the observable object.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   arg   an argument passed to the &lt;code&gt;notifyObservers&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     *                 method.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来举例使用JDK自带的观察者模式：</p>
<p>首先继承Observabe类实现被观察者逻辑：ConcreteObservable</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被观察者，自定义状态，状态变化时通知观察者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteObservable</span> <span class="keyword">extends</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String data = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeData</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.data.equalsIgnoreCase ( data )) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        setChanged ();</span><br><span class="line">        notifyObservers (data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后实现观察者接口Observer，这儿提供一个实现ConcreteObserver，实际上可以有多个观察者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span> </span>&#123;</span><br><span class="line">        System.out.println ( <span class="string">"收到"</span> + o.getClass ().getName () + <span class="string">"的DATA: "</span> + arg +<span class="string">"变化通知"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserveUsage</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConcreteObservable observable = <span class="keyword">new</span> ConcreteObservable ();</span><br><span class="line">        Observer observer = <span class="keyword">new</span> ConcreteObserver ();</span><br><span class="line">        observable.addObserver ( observer ); <span class="comment">//向被观察者添加观察者实现一对多通知</span></span><br><span class="line">        observable.changeData ( <span class="string">"FirstMsg"</span> );</span><br><span class="line">        observable.changeData ( <span class="string">"SecondMsg"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发布订阅模式是观察者模式的升级版，对事件发布方和事件订阅方进行解耦。发布方发布事件，订阅方订阅事件，再通过第三方将发布的事件通知到它的订阅者。</p>
<p>JDK中的事件监听实现了此模式：提供了EventObject类表示具体的事件类型，提供了一个空的监听器接口EventListener，方便扩展使用</p>
<p>我们来举例说明怎么使用事件监听模式：</p>
<p>首先定义一个事件类型基类AppEvent</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppEvent</span> <span class="keyword">extends</span> <span class="title">EventObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] args;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AppEvent</span><span class="params">(Object source, String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span> ( source );</span><br><span class="line">        <span class="keyword">this</span>.args = args;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String[] getArgs() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.args;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>扩展两个具体的事件类型AppReadyEvent、AppStartingEvent</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 应用启动成功READY事件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppReadyEvent</span> <span class="keyword">extends</span> <span class="title">AppEvent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AppReadyEvent</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span> ( <span class="string">"READY_EVENT"</span>, args );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 应用开始启动事件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppStartingEvent</span> <span class="keyword">extends</span> <span class="title">AppEvent</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AppStartingEvent</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span> ( <span class="string">"STARTING_EVENT"</span>, args );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义一个监听器接口AppListener定义事件通知处理协议</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AppListener</span> &lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">AppEvent</span>&gt; <span class="keyword">extends</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onAppEvent</span><span class="params">(E event)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">supportsEventType</span><span class="params">(Class&lt;? extends AppEvent&gt; eventType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>扩展实现两个具体的监听器PrepareContextAppListener、SendMsgAppListener分别响应两个事件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 监听应用开始启动事件，用于准备上下文</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrepareContextAppListener</span> <span class="keyword">implements</span>  <span class="title">AppListener</span>&lt;<span class="title">AppStartingEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAppEvent</span><span class="params">(AppStartingEvent event)</span> </span>&#123;</span><br><span class="line">        System.out.println ( <span class="string">"PREPARE CONTEXT监听器："</span> + <span class="keyword">this</span>.getClass ().getName ()</span><br><span class="line">                +<span class="string">"\n收到APP STARTING事件："</span> + event.getClass ().getName ()</span><br><span class="line">                + <span class="string">"\n收到事件参数："</span> + Arrays.toString (event.getArgs ()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsEventType</span><span class="params">(Class&lt;? extends AppEvent&gt; eventType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> AppStartingEvent.class.isAssignableFrom(eventType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 监听应用启动成功事件，用于通知消息</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMsgAppListener</span> <span class="keyword">implements</span> <span class="title">AppListener</span>&lt;<span class="title">AppReadyEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAppEvent</span><span class="params">(AppReadyEvent event)</span> </span>&#123;</span><br><span class="line">        System.out.println ( <span class="string">"SEND MSG监听器："</span> + <span class="keyword">this</span>.getClass ().getName () +</span><br><span class="line">                <span class="string">"\n收到APP READY事件："</span> + event.getClass ().getName () +</span><br><span class="line">                <span class="string">"\n收到事件参数："</span> + Arrays.toString (event.getArgs ()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsEventType</span><span class="params">(Class&lt;? extends AppEvent&gt; eventType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> AppReadyEvent.class.isAssignableFrom(eventType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义一个第三方工具类AppEventMulticaster用于将事件和监听器组合起来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 事件广播类：关联事件和监听器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppEventMulticaster</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;AppListener&lt;?&gt;&gt; listeners = <span class="keyword">new</span> HashSet ();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAppListener</span><span class="params">(AppListener&lt;?&gt; listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.listeners.add ( listener );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据事件类型自动选择相应的监听器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multicasterEvent</span><span class="params">(AppEvent event)</span> </span>&#123;</span><br><span class="line">        Iterator var = <span class="keyword">this</span>.getApplicationListeners(event).iterator();</span><br><span class="line">        <span class="keyword">while</span>(var.hasNext()) &#123;</span><br><span class="line">            AppListener&lt;AppEvent&gt; listener = (AppListener)var.next();</span><br><span class="line">            listener.onAppEvent ( event );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从所有监听器中选择出监听特定事件的监听器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> Collection&lt;AppListener&lt;?&gt;&gt; getApplicationListeners(AppEvent event) &#123;</span><br><span class="line">        List&lt;AppListener&lt;?&gt;&gt; allListeners = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        Iterator var = listeners.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var.hasNext()) &#123;</span><br><span class="line">            AppListener&lt;?&gt; listener = (AppListener)var.next();</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.supportsEvent(listener, event.getClass ())) &#123;</span><br><span class="line">                allListeners.add(listener);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> allListeners;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> eventType</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">supportsEvent</span><span class="params">(AppListener&lt;?&gt; listener, Class&lt;? extends AppEvent&gt; eventType)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> listener.supportsEventType ( eventType );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，我们来使用监听器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 事件监听器模式 （发布订阅模式）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventUsage</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AppEventMulticaster appEventMulticaster = <span class="keyword">new</span> AppEventMulticaster ();</span><br><span class="line"></span><br><span class="line">        SendMsgAppListener sendMsgAppListener = <span class="keyword">new</span> SendMsgAppListener ();</span><br><span class="line">        appEventMulticaster.addAppListener ( sendMsgAppListener );</span><br><span class="line"></span><br><span class="line">        PrepareContextAppListener prepareContextAppListener = <span class="keyword">new</span> PrepareContextAppListener ();</span><br><span class="line">        appEventMulticaster.addAppListener ( prepareContextAppListener );</span><br><span class="line"></span><br><span class="line">        appEventMulticaster.multicasterEvent ( <span class="keyword">new</span> AppStartingEvent ( <span class="keyword">new</span> String[] &#123;<span class="string">"StaringParam1"</span>, <span class="string">"StaringParam2"</span>&#125; ));</span><br><span class="line">        appEventMulticaster.multicasterEvent ( <span class="keyword">new</span> AppReadyEvent ( <span class="keyword">new</span> String[] &#123;<span class="string">"ReadyParam1"</span>, <span class="string">"ReadyParam2"</span>&#125;  ) );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PREPARE CONTEXT监听器：com.example.demo.event.PrepareContextAppListener</span><br><span class="line">收到APP STARTING事件：com.example.demo.event.AppStartingEvent</span><br><span class="line">收到事件参数：[StaringParam1, StaringParam2]</span><br><span class="line">SEND MSG监听器：com.example.demo.event.SendMsgAppListener</span><br><span class="line">收到APP READY事件：com.example.demo.event.AppReadyEvent</span><br><span class="line">收到事件参数：[ReadyParam1, ReadyParam2]</span><br></pre></td></tr></table></figure>
<p>可见广播发布具体的事件，相应的监听器会收到通知进行自己的逻辑处理</p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>知识点</title>
    <url>/article/%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>语言：java</p>
<p>知识点： 基础、集合、并发、多线程、NIO（Netty）、JVM</p>
<p>协议：TCP/IP、HTTP、WEBSOCKET</p>
<p>编程：设计模式</p>
<h3 id="基础">基础</h3>
<h4 id="自动装箱和拆箱"><strong>自动装箱和拆箱</strong></h4>
<p>部分基础数据类型与对应的包装类进行运算时，编译器自动进行转换（装箱：valueOf，拆箱：intValue、floatValue…）</p>
<p>int对应包装类Integer会缓存-128～127范围的整型</p>
<p>short对应包装类Short会缓存-128～127范围的短整型</p>
<p>long对应包装类Long会缓存-128～127范围的长整型</p>
<p>char对应包装类Character会缓存0～127范围的字符（java的char占两个字节存的是unicode码，表示数据范围0～65525）</p>
<p>byte对应包装类Byte会缓存-128～127范围的字节，即byte所表示的数据范围都会被缓存</p>
<p>boolean、float和double没有缓存</p>
<h4 id="java传参方式">java传参方式</h4>
<ol>
<li>
<p>环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ SPRING_APPLICATION_JSON=&apos;&#123;&quot;acme&quot;:&#123;&quot;name&quot;:&quot;test&quot;&#125;&#125;&apos; java -jar myapp.jar</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>系统变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ java -Dspring.application.json=&apos;&#123;&quot;name&quot;:&quot;test&quot;&#125;&apos; -jar myapp.jar</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>命令行参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ java -jar myapp.jar --spring.application.json=&apos;&#123;&quot;name&quot;:&quot;test&quot;&#125;&apos;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="18-hashmap多线程不安全">1.8 HashMap多线程不安全</h4>
<p>举例说明：同时put两个 key1-value1 和key2-value2时，如果key1和key2的hash值相同，则产生hash碰撞，将放到同一个index下的链表上，正确情况是：链表上有两个元素：一个是key1-value1节点，一个是key2-value2节点。但是多线程下可能出现都向同一个Node的next去添加新节点的情况，此时前一个添加的node将被后面的覆盖，导致前一个put的key-value丢失</p>
<h4 id="18-concurrenthashmap-bug">1.8 ConcurrentHashMap Bug</h4>
<p><strong>computeIfAbsent</strong>函数添加节点的时候如果在computeFunction里有递归调用或者修改Map的操作，将导致死循环。1.9修复了此bug，会抛出ConcurrentModifyException</p>
<h4 id="多线程">多线程</h4>
<p><img src="https://qiaojiande-1259482780.cos.ap-chengdu.myqcloud.com/201908/image-20200416163440212.png" alt=""></p>
<h4 id="线程池">线程池</h4>
<p>​	JDK原生线程池：接收任务大于核心线程数后，会先将任务放到阻塞队列，只有队列满了后才新创建线程。这种线程池模型适合处理CPU密集型任务。</p>
<p>​	Tomcat/Jetty/Dubbo：自建线程池或者扩展自JDK原生线程池：接收任务大于核心线程数后，会先创建新的线程来处理任务，只有当前活跃线程达到最大线程数后才将任务放到阻塞队列。这种线程池模型适合处理IO密集型任务。</p>
<h4 id="jvm"><strong>JVM</strong></h4>
<p>自动内存管理：</p>
<p>JVM之类加载：java虚拟机是字节码执行引擎，提供跨平台特性。虚拟机读入二进制字节码流（类加载阶段），默认是双亲委托加载模型，SPI接口定义需要bootstrap类加载器去加载第三方接口实现类，但是双亲委托加载模型限制了bootstrap类加载器不可以加载用户类，因此引入了线程上下文类加载器（默认为App类加载器），将第三方类加载到线程上下文加载器中去</p>
<p>JVM之内存模型：每个线程独享的工作内存、所有线程共享的主内存、并发控制提供语言层面的volatile、synchronized</p>
<p>JVM之内存区域划分：线程共享：堆内存、直接内存、元数据区；线程独享：线程栈、本地方法栈、程序计数器</p>
<p>JVM之内存管理：</p>
<p><img src="https://qiaojiande-1259482780.cos.ap-chengdu.myqcloud.com/201908/jvm-gc-flags.png" alt=""></p>
<p>​	1. 垃圾回收算法：</p>
<ul>
<li>
<p>年轻代：<u>Serial</u>、<u>ParNew</u>、Parallel Scavenge、G1</p>
<pre><code>	* Serial特点：单线程收集，适合单CPU场景，执行GC时完全STW，可以与老年代CMS搭配使用
	* ParNew特点：多线程收集，适合多CPU场景，执行GC时完全STW，关注尽量缩短GCSTW时间，可以与老年代CMS搭配使用
	* Parallel Scavenge特点：多线程收集，适合多CPU场景，执行GC时完全STW，关注吞吐量优先，可以使用自适应策略调整年轻代、老年代大小
	* G1特点：分代收集，年轻代使用复制算法；将内存分成大小不等的Region，只对需要回收的Region执行GC，提高了并发程度。缺点：Region大小固定对应连续大内存的分配容易导致OOM
</code></pre>
</li>
<li>
<p>老年代：Serial Old、Parallel Old、<u>CMS</u>、G1</p>
<ul>
<li>
<p>Serial Old特点：Serial的老年代版本</p>
</li>
<li>
<p>Parallel Old特点：Parrallel Scavenge的老年代版本</p>
</li>
<li>
<p>CMS特点：将GC细分为四个步骤，将STW的时间缩短；</p>
<ul>
<li>
<p>初始标记：STW</p>
</li>
<li>
<p>并发标记：GC线程和用户线程并发执行</p>
</li>
<li>
<p>重新标记：STW</p>
</li>
<li>
<p>并发清除：GC线程和用户线程并发执行</p>
<p>提高了并发度的同时，CPU、内存占用增加，提供CMSInitiatingOccupancyFraction参数表示老年代使用量达到多大比例就进行FullGC，默认为68%</p>
<p>基于标记清除算法，导致内存碎片，提供UseCMSCompactAtFullCollection参数表示在FullGC时执行内存碎片整理，提高CMSFullGCBeforeCompaction参数表示几次FullGC后才执行一次内存碎片整理。</p>
</li>
</ul>
</li>
<li>
<p>G1特点：分代收集，老年代使用标记整理算法，没有内存碎片。引入可预测的的停顿模型来降低STW时间，提供MaxGCPauseMillis参数设置最大GC停顿时间供JVM参考</p>
</li>
</ul>
</li>
<li>
<p>Java8 默认GC是年轻代：Parallel Scavenge + 老年代：Serial Old；对应的JVM参数是：-XX:+UseParallelGC</p>
<p>可通过命令查询java的默认GC：java -XX:+PrintCommandLineFlags -version</p>
<p>可通过命令：jps -v 查出运行中的JVM进程，然后：jinfo -flag UseParallelOldGC pid，即可知道是否使用这个GC</p>
</li>
<li>
<p>G1对大内存更有优势（4核8G以上），java9以上的 默认GC是G1</p>
</li>
<li>
<p>G1最佳实践：</p>
<ul>
<li>
<p>设置堆内存大小：一般将初始堆和最大堆设置一样，避免GC后的内存重新分配。初始堆大小（默认值为机器内存的1/64）： -Xms，最大堆大小（默认值为机器内存的1/4）：-Xmx</p>
</li>
<li>
<p>不要设置年轻代-Xmn大小</p>
</li>
<li>
<p>设置STW最大停顿时间（参考值）：-XX:MaxGCPauseMillis=n</p>
</li>
<li>
<p>设置堆内存占用百分比达到多少时触发并发GC周期，默认值45：-XX:InitiatingHeapOccupancyPercent=n</p>
</li>
<li>
<p>增大标记线程数量：-XX:ConcGCThreads=n</p>
</li>
<li>
<p>打印GC日志：-XX:PrintGCDetails、-XX:+PrintGCDateStamps、-Xloggc:path</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>
<p>CMS最佳实践：</p>
<ul>
<li>
<p>设置堆内存大小</p>
</li>
<li>
<p>打开老年代内存碎片整理：-XX:+UseCMSCompactAtFullCollection</p>
</li>
<li>
<p>在打开碎片整理时设置多少次FullGC后进行一次内存碎片整理： -XX:CMSFullGCsBeforeCompaction=n</p>
</li>
<li>
<p>设置老年代占用内存比例达到多少开始进行CMS GC（默认68%），后面的GC是JVM自己决定的，这个只是第一次开始进行CMS GC的阈值：-XX:CMSInitiatingOccupancyFraction=n</p>
</li>
<li>
<p>代码执行显示GC：System.gc时默认会执行完全STW的Full GC，打开此参数使用CMS GC：-XX:+ExplicitGCInvokesConcurrent</p>
</li>
<li>
<p>当CMS GC时间过长且是因为重标记时间过长，可以打开此参数，使得在重标记前进行一次YoungGC减小年轻代对象大小，减小重标记全局扫描对象数：-XX:+CMSScavengeBeforeRemark</p>
</li>
<li>
<p>JDK8以前的版本，永久代不会自动被回收。当类加载卸载频繁时，打开此参数回收无用的类和常量，避免永久代区OOM（JDK8及以后不用设置此参数）：-XX:-CMSClassUnloadingEnabled</p>
</li>
<li>
<p>设置并发CMS线程数(默认值：ConcGCThreads = (ParallelGCThreads + 3)/4，ParallelGCThreads=8+( Processor - 8 ) ( 5/8 ))：-XX:ConcGCThreads=n</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>
<p>JVM参数调优最佳实践：</p>
<ul>
<li>
<p>确定程序稳定运行时活跃数据（多次FullGC后老年代大小）占用的内存总大小：activity_num</p>
</li>
<li>
<p>设置堆内存总大小：4 * activity_num （初始堆大小和最大堆大小设置一样避免内存分配）</p>
</li>
<li>
<p>YoungGC频繁：增大年轻代大小，年轻代晋升老年代动态策略（1、晋升年龄阈值：默认15；2、当累积某个年龄的对象大小超过survivor区的一半时，直接晋升老年代）</p>
</li>
<li>
<p>FullGC频繁：原因：1、老年代不足；2、元数据区限制了大小且新生成类频繁导致频繁FullGC；3、大量年轻代晋升到老年代且老年代存不下；4、主动执行FullGC</p>
</li>
</ul>
</li>
</ul>
<pre><code>2. 堆内存划分：年轻代（eden区，survivor1、2区）、老年代、永久代（元数据区，JDK8以后元数据区不使用堆内存，使用本地内存，且根据加载类 的数量动态调整大小，不需要设置参数，如果设置了-XX:MaxMetaspaceSize=n来限制元数据区的最大内存，则可能出现OOM：Metaspace）
3. JVM默认参数查看：java -XX:+PrintFlagsFinal -version | grep HeapSize
4. 工具使用：
  	1. 查看堆内存使用情况：jmap -heap pid
  	2. 查看堆中对象数量和大小：jmap -histo pid
  	3. 生成当前java进程的线程方法调用栈快照：jstack pid
  	4. 生成堆内存dump文件：jmap -dump:format=b,file=heap.bin pid，然后传回本地使用visualVM分析
</code></pre>
<h4 id="netty">Netty</h4>
<p>高性能特性：</p>
<ol>
<li>
<p>IO模型（Linux epoll）</p>
</li>
<li>
<p>线程模型（reactor模式）</p>
</li>
<li>
<p>零拷贝</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">零拷贝一般大众所知是 Linux 中一种用于减少在文件（网络）读写过程中用户态与内核态互相切换，内核态数据需要 copy 到用户态的优化手段。在 Java 的中是以 FileChannel.transferTo 来体现。</span><br><span class="line">Netty 的零拷贝分为两种：</span><br><span class="line">一种是使用 FileReigon 封装了 FileChannel.transferTo 操作使得网络读写性能得到优化（基于操作系统的零拷贝技术实现）；</span><br><span class="line">另一种是使用 CompositeByteBuf 使用单个 ByteBuf 一样操作多个 ByteBuf 而不需要任何 copy，通过 slice 方法可以讲单个 ByteBuf 拆分为多个 ByteBuf 操作，但是其本质为操作一个 copy。更多的是指代 Netty 中对于数据高效率操作方式。与内核态用户态切换无关。</span><br><span class="line">Netty 对于 ByteBuf 的零拷贝让多种数据组合更加方便。零拷贝最多能减少两次无意义的 copy 操作且大幅减少内核态与用户态的上下文切换。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提供基于传输层协议（TCP、UDP）的支持和各种配置</p>
</li>
<li>
<p>提供各种开箱即用的Handler （编解码Codec，流分割LengthFieldBasedFrameDecoder等，空闲检测IdleStateHandler，序列化）</p>
</li>
</ol>
<h4 id="springboot启动流程">SpringBoot启动流程</h4>
<p>**SpringBoot 监听器：**SpringApplicationRunListeners</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EventPublishingRunListener 类在SpringBoot启动时读取AppClassLoader加载目录下的SpringBoot框架JAR包的META-INF/spring.factories文件实例化的</span><br><span class="line"></span><br><span class="line">EventPublishingRunListener类实例化的时候会初始化它的两个属性：</span><br><span class="line">初始化事件多播器：SimpleApplicationEventMulticaster</span><br><span class="line">并向此多播器添加实现了接口SpringApplicationRunListener的监听器</span><br><span class="line"></span><br><span class="line">然后使用实例化的EventPublishingRunListener初始化类SpringApplicationRunListeners并生成其实例</span><br><span class="line"></span><br><span class="line">类SpringApplicationRunListeners实例化后，调用其方法starting，starting方法又会调用其属性EventPublishingRunListener的starting方法</span><br><span class="line"></span><br><span class="line">EventPublishingRunListener的starting方法调用其属性初始化事件多播器的multicastEvent方法，此方法会遍历初始化EventPublishingRunListener时添加的监听器，通知他们事件</span><br></pre></td></tr></table></figure>
<p><strong>SpringBoot配置环境：</strong> ConfigurableEnvironment</p>
<p>**SpringBoot应用配置上下文：**ConfigurableApplicationContext</p>
<p><strong>SpringBoot 自动化配置</strong>：</p>
<p>spring-boot-xxoo-starter实际上没有任何java代码，只有个pom文件指定了依赖spring-boot-starter，</p>
<p>spring-boot-starter也没有任何java代码，只有个pom文件指定了依赖spring-boot-autoconfigure，</p>
<p>而spring-boot-autoconfigure里则包含了所有springboot官方的starter包所需要的外部依赖及自动配置文件和META_INF/spring.factories</p>
<p>非官方的starter的结构和spring-boot-autoconfigure一样包含了需要的外部依赖及自动配置文件和META_INF/spring.factories</p>
<p>SpringFactoriesLoader类的loadFactoryNames方法，入参为factoryClass和classLoader，根据指定的classLoader，加载该类加器搜索路径下的META_INF/spring.factories文件，传入的工厂类为接口，而文件中对应的类则是接口的实现类；loadFactoryNames方法返回类名集合，方法调用方得到这些集合后，再通过反射获取这些类的类对象、构造方法，最终生成实例</p>
<h4 id="springmvc执行流程">SpringMVC执行流程</h4>
<p><img src="https://qiaojiande-1259482780.cos.ap-chengdu.myqcloud.com/201908/image-20200420163224499.png" alt=""></p>
<h3 id="redis">Redis</h3>
<p><strong>HyperLogLog</strong>：redis-HyperLogLog 不精确（0.81%的错误率）的去重统计，比如：网站UV数、访问IP数等</p>
<p>原理：基数估算算法-伯努利实验-根据n次独立实验：抛掷硬币首次出现正面（或反面）所需要的最大次数k_max来估算实验的总次数n：<br>
$$<br>
n = 2^kmax<br>
$$<br>
分桶平均：将统计数据划分为m个桶，每个桶分别统计各自的k_max并能得到各自的基数预估值 n ，最终对这些 n 求调和平均得到整体的基数估计值：<br>
$$<br>
n = m * \frac{m}{\sum_{i=1}^{m}{\frac{1}{2^(k_m)}}}<br>
$$</p>
<p>16384=2^14个桶数组，每个桶6bit，一共16384*6/8/1024=12KB，一个key占用内存12KB</p>
<p>pfadd key value：将value取hash生成64bit的字符串，取hash值的前14位来计算桶数组下标，取hash的后50位中首次出现1的位数（0～50之间，6bit可存放到数值64，因此够用），然后放入对应的桶中</p>
<p>pfcount key：根据估算公式：修正因子 * 桶数 * 调和平均数；m为桶的个数16384，得到估算值<br>
$$<br>
const * m * \frac{m}{\sum_{i=1}^{m}{\frac{1}{2^(k_m)}}}<br>
$$<br>
为了节省内存空间，redis不会直接用16384个6bit桶存储1个HyperLogLog对象，而是先用稀疏存储（针对连续多个桶的计数为0进行存储优化，针对连续多个桶的计数都不为0且相等也进行存储优化），再用密集存储（12K，设定稀疏存储转密集存储的阈值）的方式</p>
<h3 id="日志框架使用">日志框架使用</h3>
<p>面向程序员的只是日志门面，具体需要哪个日志框架，选择相应的桥接器和日志实现框架。</p>
<ol>
<li>刚开始： 第三方日志系统：log4j等</li>
<li>JDK自带log： JUL（Java Util Log）加入</li>
<li>日志门面JCL（Java Common Logging）问世，其他日志实现自己桥接到JCL(桥接器)</li>
<li>日志门面SLF4J问世，加上自带日志实现Logback，其他日志实现自己桥接到SLF4J（桥接器 xxx-over-slf4j）</li>
<li>Log4j2问世，自带日志门面log4j2-api，加上日志实现log4j2-core</li>
</ol>
<p>至此，日志门面有三个了：JCL、SLF4J、log4j2-api，日志实现有4个：JUL、log4j、logback、log4j2-core</p>
<p>一个字：乱</p>
<p>实际项目中使用日志，应该遵循以下规则：</p>
<ol>
<li>总是使用日志门面：推荐SLF4J</li>
<li>只添加一个日志实现的依赖：推荐log4j2</li>
<li>使用第三方库，有必要排出第三方库中的日志实现依赖</li>
<li>每一个日志的实现框架都有自己的配置文件。使用slf4j以后，<strong>配置文件还是做成日志实现框架自己本身的配置文件；比如使用slf4j+log4j2，则需要的配置文件为log4j2.xml</strong></li>
</ol>
<p>Spring-boot项目默认使用：SLF4J + logback，且把其他的日志都替换成了slf4j</p>
<p>SpringBoot项目使用slf4j+log4j2配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="单点登录">单点登录</h3>
<h3 id="秒杀平台设计">秒杀平台设计</h3>
<p>问题：高并发、超卖、恶意请求、链接暴露</p>
<p>思路：</p>
<p>将请求尽量拦截在系统上游（用户页面-cdn缓存-Nginx负载均衡-服务器集群-Redis-消息队列-Mysql）</p>
<p><img src="https://qiaojiande-1259482780.cos.ap-chengdu.myqcloud.com/201908/image-20200420170520211.png" alt=""></p>
<h3 id="算法">算法</h3>
<p>单链表反转</p>
<p>动态规划-完全背包问题</p>
<p>排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">冒泡排序：</span><br><span class="line">&lt;1&gt;.比较相邻的元素。如果第一个比第二个大，就交换它们两个；</span><br><span class="line">&lt;2&gt;.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</span><br><span class="line">&lt;3&gt;.针对所有的元素重复以上的步骤，除了最后一个；</span><br><span class="line">&lt;4&gt;.重复步骤1~3，直到排序完成。</span><br><span class="line"></span><br><span class="line">改进1: 设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。</span><br><span class="line"></span><br><span class="line">改进2: 传统冒泡排序中每一趟排序操作只能找到一个最大值或最小值,我们考虑利用在每趟排序中进行正向和反向两遍冒泡的方法一次可以得到两个最终值(最大者和最小者) , 从而使排序趟数几乎减少了一半。</span><br><span class="line"></span><br><span class="line">时间复杂度：O(n²)</span><br><span class="line">空间复杂度：O(1) (in-place，不需要额外空间)</span><br><span class="line">稳定排序：稳定</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">选择排序：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</span><br><span class="line"></span><br><span class="line">时间复杂度：O(n²)</span><br><span class="line">空间复杂度：O(1) (in-place，不需要额外空间)</span><br><span class="line">稳定排序：每次从未排序的数中选择最小的与未排序的第一个交换，破坏了相对顺序（比如未排序的第一个是3，第二个也是3，第三个是2也是未排序中最小的，此时交换第三个和第一个，会破坏第一个和第二个之间的相对顺序），所以不是稳定的排序</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">插入排序：采用in-place在数组上实现。具体算法描述如下：</span><br><span class="line">1. 从第一个元素开始，该元素可以认为已经被排序</span><br><span class="line">2. 取出下一个元素，在已经排序的元素序列中从后向前扫描</span><br><span class="line">3. 如果该元素（已排序）大于新元素，将该元素移到下一位置</span><br><span class="line">4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</span><br><span class="line">5. 将新元素插入到该位置后</span><br><span class="line">6. 重复步骤2~5</span><br><span class="line"></span><br><span class="line">改进： 二分插入排序：查找插入位置时使用二分查找的方式</span><br><span class="line"></span><br><span class="line">时间复杂度：O(n²) （虽然平均时间复杂度都一样，但不一定都一样快，一般：插入排序快于选择排序快于冒泡排序）</span><br><span class="line">空间复杂度：O(1) (in-place，不需要额外空间)</span><br><span class="line">稳定排序：稳定</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">希尔排序：改进的插入排序，引入一个增量序列(比如：length/2, length/2/2, ... ,1)，增量依次递减，每次依据增量对原数组进行分组直接插入排序，待到增量为1时最后一趟插入排序后即完成整个数组的排序。</span><br><span class="line"></span><br><span class="line">时间复杂度：O(nlogn)</span><br><span class="line">空间复杂度：O(1) (in-place，不需要额外空间)</span><br><span class="line">稳定性：在不同的分组中多次插入排序导致不稳定</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">归并排序：采用分治法，将已有序的子序列合并，得到完全有序的序列；类似增量序列（length/2, length/2/2, ... ,1）当增量为1时的分组自然有序，然后递归合并2，4，8长度分组，由于合并的两个分组已经有序，合并操作很简单如下：</span><br><span class="line">1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</span><br><span class="line">2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置</span><br><span class="line">3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</span><br><span class="line">4. 重复步骤3直到某一指针到达序列尾</span><br><span class="line">5. 将另一序列剩下的所有元素直接复制到合并序列尾</span><br><span class="line"></span><br><span class="line">时间复杂度：O(nlogn)</span><br><span class="line">空间复杂度：O(n) (需要额外数组长度的空间)</span><br><span class="line">稳定性：稳定</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">快速排序：也是采用分治法，在待排序的数列中，首先要找一个数字作为基准数。为了方便，我们一般选择第1个数字作为基准数（其实选择第几个并没有关系）。接下来我们需要把这个待排序的数列中小于基准数的元素移动到待排序的数列的左边，把大于基准数的元素移动到待排序的数列的右边。这时，左右两个分区的元素就相对有序了；接着把两个分区的元素分别按照上面两种方法继续对每个分区找出基准数，然后移动，直到各个分区只有一个数时为止。</span><br><span class="line">比如待排序数组为：6 1 2 7 9 3 4 5 10 8</span><br><span class="line">1、选取基准数：6</span><br><span class="line">2、然后先从右往左找一个小于 6 的数，再从左往右找一个大于 6 的数，然后交换他们。直到左右index相遇，此时再和基准数交换，得到序列：3 1 2 5 4 6 9 7 10 8</span><br><span class="line">3、再对基准数6两边的序列递归应用上述方法</span><br><span class="line">4、比如左边以3为基准数继续进行比较交换，最终得到序列：2 1 3 5 4 6 9 7 10 8</span><br><span class="line">5、继续左边，最终得到序列：1 2 3 4 5 6 9 7 10 8</span><br><span class="line">6、换右边，最终得到序列：1 2 3 4 5 6 7 8 9 10</span><br><span class="line">利用MapReduce的思想左右两边的操作可以同时进行。</span><br><span class="line"></span><br><span class="line">时间复杂度：O(nlogn)</span><br><span class="line">空间复杂度：O(n) (in-place，不需要额外空间，递归调用最坏需要O(n))</span><br><span class="line">稳定性：左右跳步交换导致不稳定</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">堆排序：</span><br><span class="line">堆：此处只讨论二叉堆，实为一颗完全二叉树，具有以下性质。</span><br><span class="line"></span><br><span class="line">任意节点小于（或大于）它的所有后裔，最小元（或最大元）在堆的根上（堆序性）。</span><br><span class="line">堆总是一棵完全树。即除了最底层，其他层的节点都被元素填满，且最底层尽可能地从左到右填入。</span><br><span class="line">将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。</span><br><span class="line">二叉堆可以用数组实现：任意节点下标i，则左节点下标为2i+1，右节点下标为2i+2，父节点下标为floor((i-1)/2)</span><br><span class="line"></span><br><span class="line">堆排序：</span><br><span class="line">1. 先将无序数组组织成二叉堆</span><br><span class="line">2. 先將堆顶元素和已排好元素前一位做交换</span><br><span class="line">3. 将交换剩下的元素继续调整成二叉堆</span><br><span class="line">4. 重复2～3步骤，直到交换完毕（共交换len-2次）</span><br><span class="line">时间复杂度：O(nlogn)</span><br><span class="line">空间复杂度：O(1) </span><br><span class="line">稳定性：不稳定</span><br></pre></td></tr></table></figure>
<h3 id="集群与分布式">集群与分布式</h3>
<p>集群：多台服务器运行同一个服务，处理同一件事</p>
<p>分布式：多台服务器各自运行不同的服务，不同的服务之间有相互调用</p>
<h3 id="linkedhashmap实现lru算法">LinkedHashMap实现LRU算法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 继承LinkedHashMap</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_CACHE_SIZE;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> cacheSize)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 使用构造方法 public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder)</span></span><br><span class="line">		<span class="comment">// initialCapacity、loadFactor都不重要</span></span><br><span class="line">		<span class="comment">// accessOrder要设置为true，按访问排序</span></span><br><span class="line">		<span class="keyword">super</span>((<span class="keyword">int</span>) Math.ceil(cacheSize / <span class="number">0.75</span>) + <span class="number">1</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">		MAX_CACHE_SIZE = cacheSize;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 超过阈值时返回true，进行LRU淘汰</span></span><br><span class="line">		<span class="keyword">return</span> size() &gt; MAX_CACHE_SIZE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="面试">面试</h3>
<hr>
<ol>
<li>
<p>简单自我介绍</p>
</li>
<li>
<p>项目经验-用两三句话说清楚项目</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">比如光速APP：</span><br><span class="line">客户端：tun2sock（将app的流量全转到代理软件上来）</span><br><span class="line">服务端：提供的方式：SS（协议加密方式）、V2RAY</span><br><span class="line">线路：自动部署、记时、流量统计、限速</span><br></pre></td></tr></table></figure>
<p>tun是操作系统支持的虚拟网卡，参考 <a href="https://www.cnblogs.com/bakari/p/10450711.html" target="_blank" rel="noopener">https://www.cnblogs.com/bakari/p/10450711.html</a> 和 <a href="http://arloor.com/posts/other/android-vpnservice-and-vpn-dev/" target="_blank" rel="noopener">http://arloor.com/posts/other/android-vpnservice-and-vpn-dev/</a></p>
<p>tun2sock要做的事可以分成三个部分：</p>
<ol>
<li>通过tun网卡拿到手机的所有IP数据包</li>
<li>将数据包用sock协议封装</li>
<li>将封装后的数据包发送给代理服务器，完成数据的转发</li>
</ol>
<p>v2ray dns模块参考 <a href="https://medium.com/@TachyonDevel/%E6%BC%AB%E8%B0%88%E5%90%84%E7%A7%8D%E9%BB%91%E7%A7%91%E6%8A%80%E5%BC%8F-dns-%E6%8A%80%E6%9C%AF%E5%9C%A8%E4%BB%A3%E7%90%86%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-62c50e58cbd0" target="_blank" rel="noopener">https://medium.com/@TachyonDevel/%E6%BC%AB%E8%B0%88%E5%90%84%E7%A7%8D%E9%BB%91%E7%A7%91%E6%8A%80%E5%BC%8F-dns-%E6%8A%80%E6%9C%AF%E5%9C%A8%E4%BB%A3%E7%90%86%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-62c50e58cbd0</a></p>
</li>
</ol>
<ol start="3">
<li>
<p>SringBoot优点、自动配置原理、启动流程（干了什么事，用到了什么设计模式）</p>
</li>
<li>
<p>java集合、并发、多线程、JVM</p>
</li>
<li>
<p>netty</p>
</li>
<li>
<p>dubbo vs spring cloud：各自特点，区别，RPC原理（通信方式http、tcp，数据协议hession、json、pb…）</p>
</li>
<li>
<p>消息队列MQ</p>
</li>
<li>
<p>分布式：一致性协议：最终一致性：两阶段提交、TCC、paxo、raft；一致性HASH</p>
</li>
<li>
<p>mysql：事务级别、建表原则、优化方式、分库分表、HA方案（主从备份，读写分离，集群部署）</p>
</li>
<li>
<p>redis：数据类型和各自应用场景，redis实现分布式锁，redis内存50%，redis 哨兵 和 cluster，淘汰策略LRU实现</p>
</li>
<li>
<p>服务运维和监控（限流、降级、熔断）</p>
</li>
<li>
<p>负载均衡方式（分层，DNS【DNS智能解析，DNS污染、DNSSec】…）</p>
</li>
<li>
<p>接口分版本方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 域名分版本：v1.api.com  v2.api.com</span><br><span class="line">2. URL分版本：/api/v1/hello  /api/v2/hello</span><br><span class="line">3. 参数分版本：参数加上version字段</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>性能测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//参考 陈皓博客：性能测试应该怎么做</span><br><span class="line">1. 响应时间考量目标综合选择：平均值、中位值、TP值（Top Percentile，TP50，TP90，TP99）</span><br><span class="line">2. 吞吐量（QPS）必须和响应时间挂钩：比如TP99小于100ms时的QPS是1000</span><br><span class="line">3. 吞吐量、响应时间还必须和成功率挂钩：关键系统成功率必须保证100%</span><br><span class="line"></span><br><span class="line">//具体步骤</span><br><span class="line">1. 定好前提比如：机器配置，模拟并发请求数（多少个客户端多少时间内多少个请求），TP99值必须在100ms以内，平均响应时间在500ms以内，100%请求成功</span><br><span class="line">2. 在1的限制下测试系统找到最高QPS</span><br><span class="line">3. 用2的最高QPS连续压测系统一段时间，收集系统的指标（CPU、内存、IO等），判断系统的稳定性</span><br></pre></td></tr></table></figure>
<ul>
<li>性能测试可以在本机做，得到一个基准值，再和生产环境机器测试一次数据作对比，大概得到一个性能比值，下次性能优化目标就可以定量到本机测试</li>
<li>使用Profile工具定位到每个方法的处理时长，对方法进行优化</li>
<li>单机优化方式：加本地缓存、本地异步任务线程池配置、Redis Client线程池配置（区分是Netty NIO还是BIO，Netty NIO只需要少量线程池数量，而BIO只能堆线程池数量了），JDBC Client线程池（区分是NIO还是BIO）配置</li>
<li>线程池的配置参数: 核心线程数、最大线程数、队列长度的设置要综合考虑CPU、内存、JDBC线程池、REDIS线程池的配置</li>
<li>再提升性能，就要上分布式+集群了</li>
</ul>
</li>
</ol>
<ol start="15">
<li>
<p>压力测试</p>
</li>
<li>
<p>浏览器访问www.google.com整个流程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. DNS解析、hosts文件、DNS Server、DNS缓存、DNS记录（A、CNAME）DNS负载均衡</span><br><span class="line">2. http vs https（证书，单向认证【浏览器访问网址都是单向认证】，双向认证）</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>自己完成的最有挑战性、最难忘、最成功的事</p>
</li>
</ol>
<p>​</p>
]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
</search>
